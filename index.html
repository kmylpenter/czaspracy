<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8">
  <title>Rejestracja czasu pracy</title>

 <script src="https://apis.google.com/js/api.js"></script>
<script src="https://accounts.google.com/gsi/client"></script>


  <style>

:root {
  --main-bg: #f3f7fa;
  --accent1: #3a86ff;
  --accent1-light: #e0eeff;
  --accent2: #f9a826;
  --glass-bg: rgba(255,255,255,0.55);
  --glass-blur: blur(8px);
  --border: 1.5px solid rgba(60, 70, 100, 0.10);
  --tile-radius: 18px;
  --shadow1: 0 8px 32px rgba(60,70,100,0.08);
  --shadow2: 0 2px 12px rgba(60,70,100,0.07);
  --error: #d80000;
  --green: #1dd1a1;
  --yellow: #ffd600;
}

/* ———— GLOBAL ———— */
body {
  font-family: 'Segoe UI', 'Montserrat', Arial, sans-serif;
  margin: 0;
  padding: 0;
  background: var(--main-bg);
  color: #222;
  display: flex;
  flex-direction: column;
  align-items: center;
  min-height: 100vh;
}
body::after {
  content: "";
  position: fixed;
  top: 0; left: 0;
  width: 100vw; height: 100vh;
  background: url('https://raw.githubusercontent.com/kmylpenter/czaspracy/main/Finalkmylpenter_3.0_trademark_final.png') no-repeat center center;
  background-size: contain;
  opacity: 0.03;
  pointer-events: none;
  z-index: 0;
}

#clock {
  font-size: 1.18rem;
  letter-spacing: 0.06em;
  font-weight: 500;
  margin-bottom: 0;
  margin-top: 16px;
  color: var(--accent1);
  text-shadow: 0 1px 1px rgba(58,134,255,0.06);
  text-align: center;
  width: 100vw;
}
h2 {
  font-size: 2rem;
  margin-top: 26px;
  margin-bottom: 8px;
  text-align: center;
  width: 100vw;
}
h3 {
  margin: 20px 0 0 0;
}

.screen {
  display: none;
  flex-direction: column;
  align-items: center;
  width: 100%;
}
.active {
  display: flex;
}

.nav-bar {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 10px;
  padding: 10px;
  position: static;
  width: 100%;
  box-sizing: border-box;
}

/* ———— TILES / GRID ———— */
.grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
  gap: 10px;
  margin: 20px;
  width: 90%;
  max-width: 800px;
  justify-content: center;
  justify-items: center;
}
@media (max-width: 650px) {
  .grid { font-size:0.95rem; gap:8px;}
}
@media (max-width: 400px) {
  .grid {
    grid-template-columns: 1fr !important;
    justify-content: center;
    justify-items: center;
  }
}

.tile {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  width: 100px;
  height: 70px;
  white-space: normal;
  word-break: break-word;
  text-align: center;
  padding: 10px;
  border-radius: var(--tile-radius);
  box-shadow: var(--shadow2);
  cursor: pointer;
  transition: all 0.18s cubic-bezier(.6,1.5,.45,1);
  border: var(--border);
  background: var(--glass-bg);
  backdrop-filter: var(--glass-blur);
  font-weight: 500;
  margin: 0;
  position: relative;
}
.tile:hover {
  background: var(--accent1-light);
  transform: scale(1.06) translateY(-1px);
  box-shadow: 0 6px 24px rgba(60,70,100,0.12);
}
.tile.selected {
  background: var(--accent1-light);
  border: 2px solid var(--accent1);
  box-shadow: 0 0 0 2px var(--accent1-light);
}
.tile.clicked { animation: pop 0.22s ease-out; }
@keyframes pop {
  0%   { transform: scale(1);}
  50%  { transform: scale(1.08);}
  100% { transform: scale(1);}
}
/* Kafle w poszczególnych krokach */
.tile-step1 { background: var(--glass-bg);}
.tile-step2 { background: var(--glass-bg);}
.tile-step3 { background: var(--glass-bg);}
.tile-step4 { background: var(--glass-bg) !important;}
/* Kolory statusów */
.tile-status-green  { background: #d4edda !important; border: 2px solid #28a745;}
.tile-status-yellow { background: #fff3cd !important; border: 2px solid #ffc107;}
.tile-status-red    { background: #f8d7da !important; border: 2px solid #dc3545;}
/* Ostatnio używane */
.tile.recent {
  background: #fffbe6 !important;
  border: 2px dashed #ffc107;
}

/* Kafelki z godzinami (małe) */
#step5 .hour-options .tile,
#hourTiles .tile {
  width: 50px;
  height: 50px;
  padding: 5px;
  font-size: 1rem;
}

/* ———— BUTTONS ———— */
button, .back-button {
  margin: 10px;
  padding: 12px 28px;
  font-size: 1.12rem;
  cursor: pointer;
  border: none;
  border-radius: 10px;
  background: var(--accent1);
  color: #fff;
  transition: background 0.15s, box-shadow 0.15s;
  box-shadow: 0 2px 6px rgba(60,70,100,0.10);
  font-weight: 500;
  letter-spacing: 0.03em;
  outline: none;
  position: relative;
  z-index: 1;
}
button:hover, .back-button:hover {
  background: #5aa0ff;
}
.back-button {
  background: #e0e0e0;
  color: #333;
  box-shadow: none;
}
.back-button:hover {
  background: #d0d0d0;
  color: #222;
}

/* Lepsze guziki na podsumowaniu */
#step5 button {
  margin: 12px 12px 0 0;
  padding: 14px 34px;
  font-size: 1.12rem;
  min-width: 130px;
  min-height: 48px;
  white-space: nowrap;
}
#step5 button:last-child { margin-right: 0; }
@media (max-width: 600px) {
  #step5 button {
    width: 100%;
    margin: 10px 0 0 0;
    display: block;
    font-size: 1rem;
    padding: 16px 0;
    min-width: unset;
  }
}

/* Przycisk X do usuwania */
.remove-btn {
  float: right;
  background: none !important;
  border: none;
  font-size: 1.25rem;
  color: var(--error);
  cursor: pointer;
  margin-top: -8px;
  margin-right: -8px;
  padding: 0;
  transition: color 0.16s;
}
.remove-btn:hover { color: #ff0000; }

/* ———— TIMER ———— */
.summary-entry.row-timer {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 16px;
  padding: 10px 10px;
  margin: 8px 0;
  background: var(--glass-bg);
  border-radius: 8px;
  box-shadow: var(--shadow2);
  font-size: 1.02rem;
  border: var(--border);
  backdrop-filter: var(--glass-blur);
}
.timer-col.project   { min-width: 80px; font-weight: bold; }
.timer-col.category  { min-width: 80px; }
.timer-col.subcategory { min-width: 100px; }
.timer-col.time      { min-width: 80px; font-family: 'Consolas', monospace; }
.timer-col.button    { margin-left: auto; }
@media (max-width: 650px) {
  .summary-entry.row-timer { flex-wrap: wrap; font-size:0.95rem; gap:8px;}
  .timer-col.project, .timer-col.category, .timer-col.subcategory, .timer-col.time { min-width:unset;}
}

/* ———— PODSUMOWANIE ———— */
.summary-entry {
  margin: 10px 0;
  padding: 10px;
  background: var(--glass-bg);
  border-radius: 10px;
  box-shadow: var(--shadow2);
  border: var(--border);
  position: relative;
}
.summary-entry-container {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 16px;
  justify-content: center;
  max-width: 800px;
  margin: 20px auto;
}
@media (max-width: 800px) {
  .summary-entry-container {
    grid-template-columns: 1fr;
    width: 98vw;
    margin: 6px 0;
  }
}

/* Łączna liczba godzin */
.total-hours {
  font-size: 2.5rem;
  font-weight: bold;
  margin-left: 20px;
}
.total-hours.red { color: var(--error);}
.total-hours.green { color: var(--green);}

/* ———— GODZINY ———— */
.hour-options {
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  gap: 10px;
  margin-top: 10px;
  width: 90%;
  max-width: 800px;
}
@media (max-width: 650px) {
  .hour-options { grid-template-columns: repeat(4, 1fr);}
}
@media (max-width: 400px) {
  .hour-options { grid-template-columns: repeat(2, 1fr);}
}

/* Ukryj wybór godzin na wejściu do kroku 4 */
#hourSection { display: none; }

/* ———— POPUPY I TOAST ———— */
#toast {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  background: var(--green);
  color: white;
  padding: 10px 24px;
  border-radius: 12px;
  font-size: 1.04rem;
  display: none;
  z-index: 9999;
  box-shadow: 0 2px 18px rgba(60,70,100,0.14);
  font-weight: 500;
}
#toast.error {
  background: var(--error);
}

/* Edycja wpisów: styl tabelki */
#entries-popup table {
  font-size: 0.94rem;
  border-collapse: collapse;
  width: 100%;
  background: var(--glass-bg);
  backdrop-filter: var(--glass-blur);
  border-radius: 10px;
  overflow: hidden;
}
#entries-popup table th,
#entries-popup table td {
  border: 1px solid #eee;
  padding: 6px;
  text-align: left;
}
#entries-popup table th {
  background: var(--accent1-light);
}
#entries-popup table td > button {
  padding: 0;
  margin: 0;
  line-height: 1;
  font-size: inherit;
  background: none;
  border: none;
  cursor: pointer;
  vertical-align: middle;
}
#entries-popup h3 { margin-top: 0; }

/* Inne poprawki */
#recent-projects-container, #all-projects-container {
  width: 90%;
  max-width: 800px;
  margin-top: 20px;
  background: none;
}
#subcategories {
  background: none !important;
}


    
  </style>
</head>
<body>
<h3 id="clock" style="margin-top: 0;"></h3>
<div id="toast"></div>

 <div class="nav-bar" id="backButtonContainer">
  <button class="back-button" id="backBtn" onclick="goBack()">⬅ Wstecz</button>
  <button id="addBtn" class="back-button" style="margin-left: 10px;" onclick="handleAddCustom()">➕ Dodaj</button>
  <button class="back-button" id="viewEntriesBtn" onclick="showRecentEntries()">📋 Zobacz wpisy</button>
  <button id="timer-toggle-btn" onclick="handleTimerToggle()" style="display:none; margin-left:10px;">⏱ Timer</button>
  <button id="go-summary-btn" class="back-button" onclick="goToSummary()" style="display:none;">📊 Podsumowanie</button>
</div>




  <h2 id="step-title">Jak masz na imię?</h2>

  <div class="screen active" id="step1">
    <div class="grid" id="workers"></div>
  </div>
<div class="screen" id="step2">

  <button onclick="fetchProjectsFromSheet()">🔄 Aktualizuj projekty</button>

  <!-- Sekcja ostatnio używane -->
  <div id="recent-projects-container" style="width:90%; max-width:800px; margin-top:20px;">
    <h3>Ostatnio używane:</h3>
    <div class="grid" id="recent-projects"></div>
  </div>

  <!-- Sekcja wszystkie projekty -->
  <div id="all-projects-container" style="width:90%; max-width:800px; margin-top:20px;">
    <h3>Wszystkie projekty:</h3>
    <div class="grid" id="projects"></div>
  </div>
</div>


  <div class="screen" id="step3">
<button onclick="fetchCategoriesFromSheet()">🔄 Aktualizuj kategorie</button>
    <div class="grid" id="categories"></div>
    <div id="add-category-container" style="text-align:center;">
         </div>

  </div>
 <div class="screen" id="step4">
  <!-- ➡️ tutaj przycisk odświeżania zadań -->
  <div id="task-update-container" style="width:90%; max-width:800px; margin-bottom:10px; text-align:center;">
    <button onclick="handleUpdateTasks()">🔄 Aktualizuj zadania</button>
  </div>

  <!-- lista kafelków z zadaniami -->
  <div class="grid tile-step4" id="subcategories"></div>

  <!-- wybór godzin -->
  <div id="hourSection" style="display:none;">
    <h3>Wybierz liczbę godzin:</h3>
    <div class="hour-options" id="hourTiles"></div>
  </div>
</div>
  <div class="screen" id="step5">
    <div id="summary"></div>
    <p><strong>Łączna liczba godzin:</strong> <span id="totalHours">0</span> h</p>
    <button onclick="addAnotherProject()">Dodaj kolejny projekt</button>
    <button onclick="resetForm()">Zacznij od nowa</button>
    <button onclick="submitData()">Zapisz</button>
  </div>

  <script>
// Wstaw do funkcji updateTimerButtonVisibility:
function updateTimerButtonVisibility() {
    const btn = document.getElementById('timer-toggle-btn');
    if (!state.worker || !TIMER_USERS.includes(state.worker)) {
        btn.style.display = 'none';
        return;
    }
    btn.style.display = 'inline-block';

    // UWAGA! Bierz datę ze state.summaryDate jeśli istnieje
    const dateStr = state.summaryDate || getDayString();
    const data = getFullTimerData(state.worker, dateStr);
    const anyActive = (data.sessions||[]).some(s => s.isRunning || !s.savedToSheet);
    let timerState = data.timerState || "off";
    if (anyActive) timerState = "inProgress"; // lub "yellow"

    btn.textContent = (timerState === 'on' ? "⏱ Timer: ON" :
                      timerState === 'off' ? "⏱ Timer: OFF" :
                      "⏱ Timer: W TRAKCIE");
    btn.style.background = timerState === 'on' ? "#28a745" : 
                          timerState === 'off' ? "#d80000" : "#ffc107";
    btn.style.color = (timerState === 'on' || timerState === 'off') ? "#fff" : "#222";
}


// Pokazuje/ukrywa przycisk "Podsumowanie" gdy aktywny tryb timera
function updateSummaryButtonVisibility() {
  const btn = document.getElementById('go-summary-btn');
  btn.style.display = timerMode ? 'inline-block' : 'none';
}

// ———— UNIWERSALNY WRAPPER Z LOGOWANIEM GOOGLE ————
async function withAuthRequest(fn) {
  try {
    // 1. Jeśli nie mamy tokena, poproś o dostęp
    if (!gapi.client.getToken()) {
      await new Promise((resolve, reject) => {
        tokenClient.callback = (resp) => {
          if (resp.error) reject(resp.error);
          else resolve();
        };
        tokenClient.requestAccessToken({ prompt: '' });
      });
    }
    // 2. Spróbuj wywołać przekazaną funkcję
    return await fn();
  } catch (e) {
    // 3. Jeśli błąd autoryzacji – spróbuj jeszcze raz po zalogowaniu
    if (
      e.status === 401 ||
      e.status === 403 ||
      (e.result && e.result.error && e.result.error.code === 401)
    ) {
      await new Promise((resolve, reject) => {
        tokenClient.callback = (resp) => {
          if (resp.error) reject(resp.error);
          else resolve();
        };
        tokenClient.requestAccessToken({ prompt: '' });
      });
      return await fn();
    } else {
      throw e;
    }
  }
}


// Funkcja przełączająca timer po kliknięciu
function handleTimerToggle() {
    if (!state.worker || !TIMER_USERS.includes(state.worker)) return;
    let timerState = getTimerState(state.worker);
    if (timerState === "off") timerState = "on";
    else if (timerState === "on") timerState = "off";
    // inProgress ustawiamy tylko w późniejszych krokach
    saveTimerState(state.worker, timerState);
    updateTimerButtonVisibility();
}


// ———– KONFIGURACJA TIMERA ————
const TIMER_STORAGE_PREFIX = "timerData_";
const TIMER_DAYS_BACK = 3;

// Zwraca datę w formacie YYYY-MM-DD
function getDayString(offsetDays = 0) {
  const d = new Date();
  d.setDate(d.getDate() - offsetDays);
  return d.toISOString().split('T')[0];
}

// Generuje klucz do localStorage dla danego użytkownika i daty
function getTimerStorageKey(worker, dateString) {
  return `${TIMER_STORAGE_PREFIX}${worker}_${dateString}`;
}

// Odczytaj dane z localStorage dla użytkownika z ostatnich 3 dni
function loadTimerDataForWorker(worker) {
  const results = [];
  for (let i = 0; i < TIMER_DAYS_BACK; i++) {
    const dayStr = getDayString(i);
    const key = getTimerStorageKey(worker, dayStr);
    const dataStr = localStorage.getItem(key);
    if (dataStr) {
      try {
        const data = JSON.parse(dataStr);
        results.push({ dayStr, data });
      } catch(e) {
        // Jeśli coś jest nie tak – usuń z localStorage
        localStorage.removeItem(key);
      }
    }
  }
  return results;
}

// Zapisuje dane timera dla użytkownika i danego dnia
function saveTimerDataForWorker(worker, dateString, timerData) {
  const key = getTimerStorageKey(worker, dateString);
  localStorage.setItem(key, JSON.stringify(timerData));
}

// Usuwa dane timera po zapisaniu do arkusza
function clearTimerDataForWorker(worker, dateString) {
  localStorage.removeItem(getTimerStorageKey(worker, dateString));
}

// 1. Funkcja konwertująca sekundy na "xh ymin"
function formatSecondsToHhMm(sec) {
  sec = parseInt(sec, 10);
  if (isNaN(sec) || sec < 0) return "-";
  const h = Math.floor(sec / 3600);
  const m = Math.floor((sec % 3600) / 60);
  let out = "";
  if (h > 0) out += `${h}h `;
  if (m > 0) out += `${m}min`;
  if (out.trim() === "") out = "0min";
  return out.trim();
}


function showPendingTimersScreen(oldTimers, worker) {
  // Ukrywamy wszystkie ekrany
  document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
  // Tworzymy popup
  let html = `<div id="pending-timers-screen" style="
      position:fixed; top:10%; left:50%; transform:translateX(-50%);
      background:white; padding:30px; box-shadow:0 0 12px rgba(0,0,0,.20);
      max-width:350px; z-index:9999; border-radius:15px;">
      <h3>Masz niezapisane pomiary czasu z poprzednich dni:</h3>
      <ul style="padding-left:18px;">`;
  oldTimers.forEach(({dayStr, data}) => {
    html += `<li style="margin-bottom: 10px;">
      <b>${dayStr}</b> — 
      <button onclick="viewPendingTimerSummary('${worker}','${dayStr}')" style="background:#3a86ff; color:white;">Wyświetl</button>
      <br>
      <span style="font-size:0.95em; color:#666;">(Ilość wpisów: ${data.entries ? data.entries.length : 0})</span>
    </li>`;
  });
  html += `</ul>
      <button onclick="skipAndClearPendingTimers('${worker}')" style="margin-top:12px; background:#d80000; color:white;">Pomiń</button>
    </div>`;
  const div = document.createElement('div');
  div.innerHTML = html;
  document.body.appendChild(div);
}


function closePendingTimersScreen() {
  const el = document.getElementById('pending-timers-screen');
  if (el) el.remove();
  showStep(2);
  renderProjects();
  updateTimerButtonVisibility();
}
function saveOldTimerToSheet(worker, dayStr) {
  // Na razie tylko usuwamy dane (mock)
  clearTimerDataForWorker(worker, dayStr);
  // Usuwamy z ekranu zapisany wpis
  const el = document.getElementById('pending-timers-screen');
  if (el) el.remove();
  // Sprawdzamy, czy są jeszcze jakieś zaległe
  const oldTimers = loadTimerDataForWorker(worker);
  if (oldTimers.length > 0) {
    showPendingTimersScreen(oldTimers, worker);
  } else {
    showStep(2);
    renderProjects();
    updateTimerButtonVisibility();
  }
  showToast("Zapisano (symulacja)");
}


// ————— ZAMIENNIK showRecentEntries —————
async function showRecentEntries() {
  try {
    const now = new Date();
    const oneWeekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);

    const res = await withAuthRequest(() =>
      gapi.client.sheets.spreadsheets.values.get({
        spreadsheetId: SPREADSHEET_ID,
        range: `${SHEET_NAME_SAVE}!A2:F`,
      })
    );
    const allEntries = res.result.values || [];
    const enriched = allEntries.map((row, i) => ({
      data: row,
      rowIndex: i + 2
    }));

    const recent = enriched.filter(obj => {
      const d = new Date(obj.data[0]);
      return !isNaN(d) && d >= oneWeekAgo;
    });

    // 4) budujemy tabelę z dodatkową kolumną „Edytuj”
    const html = `
  <div id="entries-popup" style="position:fixed; top:10%; left:50%; transform:translateX(-50%);
              background:white; padding:20px; box-shadow:0 0 10px rgba(0,0,0,0.3);
              max-height:80vh; overflow:auto; z-index:9999; border-radius:12px;">
    <h3>Ostatnie wpisy</h3>
    <table style="font-size:0.8rem; border-collapse:collapse; width:100%;">
      <thead>
        <tr>
          <th>Data</th>
          <th>Pracownik</th>
          <th>Projekt</th>
          <th>Kategoria</th>
          <th>Zadanie</th>
          <th>Godziny</th>
          <th>Edytuj</th>
          <th>Usuń</th>
        </tr>
      </thead>
      <tbody>
        ${recent.map(obj => `
          <tr>
            ${obj.data.map((col, colIdx) =>
              `<td>${colIdx === 5 ? formatSecondsToHhMm(col) : col}</td>`
            ).join('')}
            <td>
              <button onclick="editEntry(${obj.rowIndex})">✏️</button>
            </td>
            <td>
              <button onclick="deleteEntry(${obj.rowIndex})" style="color:red;">🗑️</button>
            </td>
          </tr>
        `).join('')}
      </tbody>
    </table>
    <div style="text-align:center; margin-top:10px;">
      <button onclick="document.getElementById('entries-popup').remove()">Zamknij</button>
    </div>
  </div>
`;

    // wstrzyknięcie
    const container = document.createElement('div');
    container.innerHTML = html;
    document.body.appendChild(container);

  } catch (e) {
    console.error("Błąd pobierania wpisów:", e);
    showToast("Nie udało się pobrać wpisów", true);
  }
}
// Helpers: dostajesz i zapisujesz listę projektów w localStorage
function getCachedProjects() {
  try { return JSON.parse(localStorage.getItem('projekty')||'[]') }
  catch { return [] }
}
function setCachedProjects(arr) {
  localStorage.setItem('projekty', JSON.stringify(arr))
}




function viewPendingTimerSummary(worker, dayStr) {
  // Zamknij popup
  const el = document.getElementById('pending-timers-screen');
  if (el) el.remove();

  // Przejdź do ekranu podsumowania
  showStep(5);

  // Wyświetl podsumowanie timera dla wybranej daty i pracownika
  renderTimerSummary(worker, dayStr);
}


function skipAndClearPendingTimers(worker) {
  // Usuń wszystkie zaległe timery z localStorage
  for (let i = 0; i < 3; i++) {
    const dayStr = getDayString(-i);
    const key = getTimerStorageKey(worker, dayStr);
    localStorage.removeItem(key);
  }
  // Zamknij popup
  const el = document.getElementById('pending-timers-screen');
  if (el) el.remove();
  showStep(2);
  renderProjects();
  updateTimerButtonVisibility();
  showToast("Wyczyszczono niezatwierdzone pomiary", false);
}

function renderOldTimerSummary(worker, dayStr) {
  state.summaryDate = dayStr;
  renderFullSummary(worker, dayStr);
}




function getCachedTasks() {
  try { return JSON.parse(localStorage.getItem('tasksCache')||'{}') }
  catch { return {} }
}
function setCachedTasks(obj) {
  localStorage.setItem('tasksCache', JSON.stringify(obj))
}

// pobierz WSZYSTKIE zadania raz z arkusza, pogrupuj po kategorii
async function fetchTasksFromSheet() {
  if (!gapiInited) return {};
  try {
    const res = await withAuthRequest(() =>
      gapi.client.sheets.spreadsheets.values.get({
        spreadsheetId: SPREADSHEET_ID,
        range: `NoweZadania!A2:B`
      })
    );
    const rows = res.result.values || [];
    const tasksByCat = {};
    rows.forEach(([cat, task]) => {
      if (cat && task) {
        if (!tasksByCat[cat]) tasksByCat[cat] = [];
        if (!tasksByCat[cat].includes(task)) tasksByCat[cat].push(task);
      }
    });
    setCachedTasks(tasksByCat);
    if (currentStep === 4 && currentEntry?.category) {
      const list = tasksByCat[currentEntry.category] || [];
      renderTiles('subcategories', list, subcat => {
        currentEntry.subcategory = subcat;
        document.getElementById('hourSection').style.display = 'block';
      });
    }
    showToast("Zadania zaktualizowane z arkusza");
    return tasksByCat;
  } catch (e) {
    console.error("Błąd pobierania zadań:", e);
    showToast("Błąd aktualizacji zadań", true);
    return {};
  }
}


// Pobierz z localStorage lub []  
function getRecentProjects() {
  try { return JSON.parse(localStorage.getItem('recentProjects'))||[]; }
  catch { return []; }
}
function setRecentProjects(arr) {
  localStorage.setItem('recentProjects', JSON.stringify(arr));
}
// Przy wyborze projektu – wrzuć na początek, usuń duplikaty, zachowaj max 7
function updateRecentProjects(project) {
  // tylko 5 pierwszych
const recent = getRecentProjects().slice(0,5);

  const filtered = [project, ...recent.filter(p=>p!==project)];
  setRecentProjects(filtered.slice(0,7));
}


// renderowanie kafelków projektów
function renderProjects() {
  // tylko 5 pierwszych
const recent = getRecentProjects().slice(0,5);

  const recentContainer = document.getElementById('recent-projects');
  recentContainer.innerHTML = '';

  // *** DLA CELÓW DEBUGU dodaj na chwilę logi:
  console.log('renderProjects ↠ recent:', recent, 'all projects:', projects);

  // zawsze pokazuj sekcję (przynajmniej na czas testów)
  document.getElementById('recent-projects-container').style.display = 'block';

  // render kafelków „ostatnio używane”
  if (recent.length) {
    renderTiles('recent-projects', recent, selectProject);
    Array.from(recentContainer.children)
         .forEach(div => div.classList.add('recent'));
  }

  // render wszystkich projektów poniżej
  document.getElementById('all-projects-container').style.display = 'block';
  renderTiles('projects', projects, selectProject);
  addCustomProjectTile();
}



// w resetForm: od razu z cache’u, bez fetcha
async function resetForm() {
  state = { worker: null, entries: [] };
  loadProjectsFromStorage();
  // ⬇⬇⬇ To jest kluczowe
  if (gapiInited) {
    await fetchCategoriesFromSheet(); // ⬅⬅⬅ poczekaj na pobranie zanim cokolwiek dalej!
  } else {
    setTimeout(resetForm, 250);
    return;
  }
  const statusMap = await fetchWorkerStatuses();
  showStep(1);
  renderTiles('workers', workers, worker => {
  state.worker = worker;
  // 1. Najpierw sprawdzamy overnight timer
  if (checkOvernightTimer(worker)) {
    return; // wyświetlił popup, nie idź dalej!
  }
  // 2. Jeśli nie overnight, sprawdzamy stare timery
  const oldTimers = loadTimerDataForWorker(worker);
  if (oldTimers.length > 0) {
    showPendingTimersScreen(oldTimers, worker);
    return;
  }
  showStep(2);
  renderProjects();
  updateTimerButtonVisibility();
}, statusMap);

}


function checkPendingSave() {
  const pending = localStorage.getItem("pendingSave");
  if (pending) {
    showToast("Masz niezapisane dane! Kliknij tutaj, aby spróbować je zapisać.", true);
    document.getElementById('toast').onclick = () => {
      actuallySubmitPendingData();
    };
  }
}

function formatSecondsHMS(sec) {
  sec = Math.floor(sec);
  const h = Math.floor(sec / 3600);
  const m = Math.floor((sec % 3600) / 60);
  const s = sec % 60;
  return [h, m, s].map(x=>x.toString().padStart(2,'0')).join(':');
}


async function actuallySubmitPendingData() {
  const pending = localStorage.getItem("pendingSave");
  if (!pending) return;
  try {
    const { values } = JSON.parse(pending);
    await gapi.client.sheets.spreadsheets.values.append({
      spreadsheetId: SPREADSHEET_ID,
      range: `${SHEET_NAME_SAVE}!A1`,
      valueInputOption: 'USER_ENTERED',
      insertDataOption: 'INSERT_ROWS',
      resource: { values }
    });
    localStorage.removeItem("pendingSave");
    showToast("Udało się zapisać zaległe dane!");
    resetForm();
  } catch (err) {
    showToast("Dalej nie udało się zapisać! Twoje dane są bezpieczne.", true);
  }
}



    // Zwraca string daty YYYY-MM-DD
function getDayString(offset = 0) {
    const d = new Date();
    d.setDate(d.getDate() + offset);
    return d.toISOString().split('T')[0];
}

// Zwraca listę {dayStr, data} z localStorage z 3 dni wstecz
function loadTimerDataForWorker(worker) {
    const result = [];
    for (let offset = 0; offset > -3; offset--) {
        const dayStr = getDayString(offset);
        const key = `timerData_${worker}_${dayStr}`;
        const data = JSON.parse(localStorage.getItem(key) || "null");
        if (data) result.push({ dayStr, data });
    }
    return result;
}

// Zapisz stan timera (np. "on" lub "off") dla aktualnego pracownika i dnia
function saveTimerState(worker, state) {
    const dayStr = getDayString();
    const key = `timerData_${worker}_${dayStr}`;
    let data = JSON.parse(localStorage.getItem(key) || "{}");
    data.timerState = state;
    localStorage.setItem(key, JSON.stringify(data));
}

// Odczytaj stan timera (on/off/inProgress)
function getTimerState(worker) {
    const dayStr = getDayString();
    const key = `timerData_${worker}_${dayStr}`;
    let data = JSON.parse(localStorage.getItem(key) || "{}");
    return data.timerState || "off";
}

async function deleteEntry(rowIndex) {
  if (!confirm("Czy na pewno chcesz usunąć ten wpis? Tej operacji nie można cofnąć.")) return;
  try {
    await withAuthRequest(() =>
      gapi.client.sheets.spreadsheets.values.clear({
        spreadsheetId: SPREADSHEET_ID,
        range: `${SHEET_NAME_SAVE}!A${rowIndex}:F${rowIndex}`
      })
    );
    showToast("Wpis został usunięty.");
    document.getElementById('entries-popup').remove();
    showRecentEntries();
  } catch (e) {
    console.error("Błąd kasowania wpisu:", e);
    showToast("Nie udało się usunąć wpisu.", true);
  }
}


async function editEntry(rowIndex) {
  // 1) Pobieramy starą wartość
  const range = `${SHEET_NAME_SAVE}!A${rowIndex}:F${rowIndex}`;
  const getRes = await withAuthRequest(() =>
    gapi.client.sheets.spreadsheets.values.get({
      spreadsheetId: SPREADSHEET_ID,
      range
    })
  );
  const old = getRes.result.values?.[0] || [];
  const headers = ['Data','Pracownik','Projekt','Kategoria','Zadanie','Godziny'];

  // 2) Pytamy usera o nowe wartości
  const updated = old.map((val,i) => {
    const inp = prompt(`Nowa wartość dla ${headers[i]}:`, val);
    return inp == null ? val : inp;
  });

  // 3) Funkcja, która robi faktyczny update
  async function doUpdate() {
    await withAuthRequest(() =>
      gapi.client.sheets.spreadsheets.values.update({
        spreadsheetId: SPREADSHEET_ID,
        range,
        valueInputOption: 'USER_ENTERED',
        resource: { values: [updated] }
      })
    );
    showToast("Zaktualizowano wpis");
    document.getElementById('entries-popup').remove();
    showRecentEntries();
  }

  // 4) Token zawsze już będzie odświeżony, więc tylko wywołuj:
  await doUpdate();
}




function showToast(msg, isError = false) {
  const toast = document.getElementById('toast');
  if (!toast) {
    console.warn("Toast element nie istnieje:", msg);
    return;
  }

  toast.textContent = msg;
  toast.classList.toggle('error', isError);
  toast.style.display = 'block';
  setTimeout(() => {
    toast.style.display = 'none';
  }, 5000);
}


function updateClock() {
  const now = new Date();
  const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
  const dateStr = now.toLocaleDateString('pl-PL', options);
  const timeStr = now.toLocaleTimeString('pl-PL');
  document.getElementById('clock').innerText = `${dateStr}, ${timeStr}`;
}
setInterval(updateClock, 1000);
updateClock();


    // ————— USTAWIENIA —————
    const API_KEY         = "AIzaSyDDihxqon-BeTzmC-vEE4kyhRJBXTlK_lA";
    const CLIENT_ID       = "614198520540-4ann4cs5o8pchgi1u15q6n08pj87n51o.apps.googleusercontent.com";
    const SPREADSHEET_ID  = "14t8T8GexDVVlO5v-C1T0VHz94LmM5FRRNg-sXPKh2GE";
    const DISCOVERY_DOCS  = ["https://sheets.googleapis.com/$discovery/rest?version=v4"];
    const SCOPES          = "https://www.googleapis.com/auth/spreadsheets";
    const SHEET_NAME_LOAD = "Projekty";
    const SHEET_NAME_SAVE = "CzasPracy";

    // ————— ZMIENNE STANU OAuth —————
    let tokenClient;
    let gapiInited = false;
    let gisInited  = false;

    // ————— CALLBACKI ŁADOWANIA BIBLIOTEK —————
    function gapiLoaded() {
  gapi.load('client', () =>
    gapi.client.init({ apiKey: API_KEY, discoveryDocs: DISCOVERY_DOCS })
      .then(() => {
        gapiInited = true;
        resetForm(); // ← przenieś tutaj
      })
  );
}


    function gisLoaded() {
  tokenClient = google.accounts.oauth2.initTokenClient({
    client_id: CLIENT_ID,
    scope: SCOPES,
    callback: (resp) => {
      if (resp.error) {
        console.error("Token error:", resp);
        return;
      }
      actuallySubmitData();
    }
  });
  gisInited = true;

  // >>> DODAJ TEN BLOK:
  // Automatyczne odświeżanie tokena co 50 minut (3000 sekund)
  setInterval(() => {
    if (gapiInited && gisInited) {
      try {
        tokenClient.requestAccessToken({ prompt: '' });
        console.log("Token Google odświeżony automatycznie.");
      } catch(e) {
        console.warn("Nie udało się odświeżyć tokena:", e);
      }
    }
  }, 50 * 60 * 1000); // 50 minut
  // <<< KONIEC BLOKU
}


    // ————— DANE APLIKACJI —————
    const workers = ["Kamil","Paweł","Piotr","Przemek","Robert"];

    async function fetchCategoriesFromSheet() {
  if (!gapiInited) return;
  try {
    const baseCategories = ["Stal", "Drewno", "Montaż", "Biuro"];
    const res = await withAuthRequest(() =>
      gapi.client.sheets.spreadsheets.values.get({
        spreadsheetId: SPREADSHEET_ID,
        range: `NoweKategorie!A2:A`
      })
    );
    const newCategories = res.result.values?.flat() || [];
    window.categories = Array.from(new Set([
      ...baseCategories,
      ...newCategories
    ].filter(Boolean)));
    renderTiles('categories', window.categories, selectCategory);
    showToast("Kategorie zaktualizowane z arkusza");
  } catch (e) {
    console.error("Błąd pobierania kategorii:", e);
    showToast("Błąd aktualizacji kategorii", true);
  }
}



    const subcategoriesMap = {
      "Stal": ["Konstrukcja","Balustrady"],
      "Drewno": ["Przygotowanie","Produkcja","Lakierowanie"],
      "Montaż": ["Transport","Konstrukcja","Stopnie/Podstopnie","Balustrady","Pozostałe"],
      "Biuro": ["Zakupy","Faktury","Telefon","Sketchup"]
    };
    let projects = [];
    let state = { worker: null, entries: [] };
    let currentEntry = null;
    let currentStep = 1;
    let timerMode = false; // false = normalny, true = timer
    let timerData = null;  // tutaj będziemy trzymać obecny wpis timera
    let timerInterval = null; // do odliczania sekund


    // ————— POMOCNICZE —————
    function showStep(step) {
  document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
  document.getElementById(`step${step}`).classList.add('active');
  const titles = [" ","Wybierz projekt","Wybierz kategorię","Wybierz zadanie","Podsumowanie"];
  document.getElementById('step-title').innerText = titles[step-1];
  document.getElementById('addBtn').style.display = (step === 2 || step === 4) ? 'inline-block' : 'none';
  // — poprawka:
  document.querySelectorAll('.back-button').forEach(btn => {
    document.getElementById('backBtn').style.display = (step === 1 || (step === 5 && timerMode)) ? 'none' : 'inline-block';
  });

  currentStep = step;
  if (step === 4) {
    document.getElementById('hourSection').style.display = 'none';
    renderHourTiles();
  }
  updateTimerButtonVisibility();
  updateSummaryButtonVisibility();

}

function selectCategory(category) {
  currentEntry.category = category;
  showStep(4);
  const staticList = subcategoriesMap[category] || [];
  const cached = getCachedTasks()[category] || [];
  renderTiles('subcategories', Array.from(new Set([...staticList, ...cached])), subcat => {
    currentEntry.subcategory = subcat;
    if (timerMode) {
      startTaskTimer(currentEntry);
    } else {
      document.getElementById('hourSection').style.display = 'block';
    }
  });
}



// ————— Zaktualizowany handleAddCustom —————
function handleAddCustom() {
  if (currentStep === 2) { // Projekty
    const name = prompt("Podaj nazwę nowego projektu:");
    if (name && !projects.includes(name)) {
      projects.push(name);
      localStorage.setItem('projekty', JSON.stringify(projects));
      renderProjects();
      saveNewItemToSheet(name, 'NoweProjekty');
    }
  }

  if (currentStep === 3) { // Kategorie
    const name = prompt("Podaj nazwę nowej kategorii:");
    if (name && !categories.includes(name)) {
      categories.push(name);
      renderTiles('categories', window.categories, selectCategory);

      saveNewItemToSheet(name, 'NoweKategorie');
      showToast("Dodano nową kategorię");
    }
  }

  if (currentStep === 4 && currentEntry?.category) { // Zadania
    const name = prompt("Podaj nazwę nowego zadania:");
    const list = subcategoriesMap[currentEntry.category] || [];
    if (name && !list.includes(name)) {
      list.push(name);
      subcategoriesMap[currentEntry.category] = list;
      renderTiles('subcategories', list, subcat => {
  currentEntry.subcategory = subcat;
  if (timerMode) {
    startTaskTimer(currentEntry);
  } else {
    document.getElementById('hourSection').style.display = 'block';
  }
});

      saveNewTaskToSheet(currentEntry.category, name);
    }
  }
}


async function handleAddCategory() {
  const name = prompt("Podaj nazwę nowej kategorii:");
  if (!name) return;
  if (!categories.includes(name)) {
    categories.push(name);
    await saveNewItemToSheet(name, 'NoweKategorie');
    await fetchCategoriesFromSheet();  // ← dodać to
    renderTiles('categories', window.categories, category => {
      currentEntry.category = category;
      showStep(4);
      const staticList = subcategoriesMap[category]||[];
      const cached = getCachedTasks()[category]||[];
      renderTiles('subcategories', Array.from(new Set([...staticList, ...cached])), subcat => {
        currentEntry.subcategory = subcat;
        document.getElementById('hourSection').style.display = 'block';
      });
    });
    showToast("Dodano nową kategorię");
  } else {
    showToast("Taka kategoria już istnieje!", true);
  }
}



async function saveNewItemToSheet(value, sheetName) {
  if (!value || !sheetName || !gapiInited) return;

  try {
    await withAuthRequest(() =>
      gapi.client.sheets.spreadsheets.values.append({
        spreadsheetId: SPREADSHEET_ID,
        range: `${sheetName}!A:A`,
        valueInputOption: 'USER_ENTERED',
        insertDataOption: 'INSERT_ROWS',
        resource: { values: [[value]] }
      })
    );
    showToast("Zapisano nową pozycję");
  } catch (err) {
    console.error("Błąd zapisu nowej pozycji:", err);
    showToast("Błąd zapisu nowej pozycji", true);
  }
}



    function goBack() {
      if (currentStep > 1) showStep(currentStep - 1);
    }

async function fetchWorkerStatuses() {
  const statusMap = {};
  const todayStr = new Date().toISOString().split("T")[0];

  // Spróbuj wczytać z cache
  const cached = localStorage.getItem("workerStatusCache");
  if (cached) {
    try {
      const parsed = JSON.parse(cached);
      if (parsed.date === todayStr && parsed.statusMap) {
        return parsed.statusMap;
      }
    } catch (e) {
      console.warn("Błąd parsowania cache:", e);
    }
  }

  try {
    const res = await withAuthRequest(() =>
      gapi.client.sheets.spreadsheets.values.get({
        spreadsheetId: SPREADSHEET_ID,
        range: `${SHEET_NAME_SAVE}!A2:F`,
      })
    );

    const entries = res.result.values || [];
    const yesterday = new Date();
    yesterday.setDate(yesterday.getDate() - 1);
    const yesterdayStr = yesterday.toISOString().split("T")[0];

    workers.forEach(worker => {
      const hasToday = entries.some(row =>
        row[0]?.startsWith(todayStr) && row[1] === worker
      );
      const hasYesterday = entries.some(row =>
        row[0]?.startsWith(yesterdayStr) && row[1] === worker
      );

      if (hasToday) statusMap[worker] = "green";
      else if (hasYesterday) statusMap[worker] = "yellow";
      else statusMap[worker] = "red";
    });

    localStorage.setItem("workerStatusCache", JSON.stringify({
      date: todayStr,
      statusMap
    }));

  } catch (e) {
    console.error("Błąd pobierania statusów pracowników:", e);
    showToast("Nie udało się sprawdzić, kto się wpisał.", true);
  }

  return statusMap;
}





    function renderTiles(containerId, items, onClick, statusMap = {}) {
console.log("Rendertiles", { containerId, items, statusMap });

  const container = document.getElementById(containerId);
  container.innerHTML = '';
  const step = currentStep;

  const stepClass = {
    1: 'tile-step1',
    2: 'tile-step2',
    3: 'tile-step3',
    4: 'tile-step4'
  }[step] || 'tile';

  items.forEach(item => {
  const div = document.createElement('div');
  div.className = `tile ${stepClass}`;

  // Dodaj klasę statusu (jeśli dotyczy)
  if (statusMap[item]) {
    div.classList.add(`tile-status-${statusMap[item]}`);
  }

  div.innerText = item;
  div.onclick = () => {
    div.classList.add('clicked');
    setTimeout(() => div.classList.remove('clicked'), 200);
    [...container.children].forEach(c => c.classList.remove('selected'));
    div.classList.add('selected');
    onClick(item);   // ← TYLKO TO
  };
  container.appendChild(div);
});

}


    // ————— RESET I START —————
    function loadProjectsFromStorage() {
      const stored = localStorage.getItem('projekty');
      projects = stored ? JSON.parse(stored) : [];
    }

    async function resetForm() {
  state = { worker: null, entries: [], summaryDate: null };

  loadProjectsFromStorage();
  // *** NIE CZEKAJ na gapiInited tylko spróbuj zawsze pobrać kategorie z arkusza ***
  if (gapiInited) {
    await fetchCategoriesFromSheet();
  } else {
    // próbuj aż się załaduje!
    setTimeout(resetForm, 250);
    return;
  }

  const statusMap = await fetchWorkerStatuses();
  showStep(1);
  renderTiles('workers', workers, worker => {
  state.worker = worker;
console.log("Kliknięto pracownika:", worker);
console.log("Znaleziono stare timery:", loadTimerDataForWorker(worker));

  const oldTimers = loadTimerDataForWorker(worker);
  if (oldTimers.length > 0) {
    showPendingTimersScreen(oldTimers, worker);  // <-- już działa
    return;
  }
  showStep(2);
  renderProjects();
  updateTimerButtonVisibility();
}, statusMap);


}

    // ————— DYNAMICZNE TILES —————
    function addCustomProject() {
  const name = prompt("Podaj nazwę nowego projektu:");
  if (name && !projects.includes(name)) {
    projects.push(name);
    localStorage.setItem('projekty', JSON.stringify(projects));
   renderProjects();

    // zapisujemy do arkusza NoweProjekty
    saveNewItemToSheet(name, 'NoweProjekty');
  }
}


    function addCustomProjectTile() {
      const t = document.createElement('div');
      t.className = 'tile';
      t.innerText = '+ Dodaj projekt';
      t.onclick = addCustomProject;
      document.getElementById('projects').appendChild(t);
    }

// ————— NOWA funkcja do zapisu nowych zadań w dwóch kolumnach (kategoria + nazwa) —————
async function saveNewTaskToSheet(category, taskName) {
  if (!category || !taskName || !gapiInited) return;
  try {
    await withAuthRequest(() =>
      gapi.client.sheets.spreadsheets.values.append({
        spreadsheetId: SPREADSHEET_ID,
        range: `NoweZadania!A:B`, // kolumna A = kategoria, B = zadanie
        valueInputOption: 'USER_ENTERED',
        insertDataOption: 'INSERT_ROWS',
        resource: { values: [[category, taskName]] }
      })
    );
    showToast("Zapisano nowe zadanie");
  } catch (err) {
    console.error("Błąd zapisu nowego zadania:", err);
    showToast("Błąd zapisu nowego zadania", true);
  }
}



    // ————— Modyfikacja selectProject → wybór kategorii → krok 4 —————
// po wyborze kategorii:
function selectProject(project) {
  updateRecentProjects(project);
  currentEntry = { project, category: null, subcategory: null, hours: 0 };

  // --- NOWE: obsługa trybu timera ---
  if (timerMode) {
    showStep(3);
    fetchCategoriesFromSheet().then(() => {
      renderTiles('categories', window.categories, cat => {
        currentEntry.category = cat;
        showStep(4);
        const staticList = subcategoriesMap[cat] || [];
        const cached = getCachedTasks()[cat] || [];
        renderTiles(
          'subcategories',
          Array.from(new Set([...staticList, ...cached])),
          subcat => {
            currentEntry.subcategory = subcat;
            // --- START TIMERA ---
            startTaskTimer(currentEntry);
          }
        );
      });
    });
    return; // NIE kontynuuj starej ścieżki!
  }

  // --- Stary tryb normalny ---
  showStep(3);
  fetchCategoriesFromSheet().then(() => {
    renderTiles('categories', window.categories, cat => {
      currentEntry.category = cat;
      showStep(4);
      const staticList = subcategoriesMap[cat] || [];
      const cached = getCachedTasks()[cat] || [];
      renderTiles(
        'subcategories',
        Array.from(new Set([...staticList, ...cached])),
        subcat => {
          currentEntry.subcategory = subcat;
          if (timerMode) {
            startTaskTimer(currentEntry);
          } else {
            document.getElementById('hourSection').style.display = 'block';
          }
        }
      );
    });
  });
}



function stopCurrentTaskTimer() {
    if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
    }
    if (timerData && timerData.isRunning) {
        // Dodaj czas do totalSeconds
        const now = Date.now();
        timerData.totalSeconds += Math.floor((now - timerData.startTime) / 1000);
        timerData.isRunning = false;
    }
}
function toggleStartStopTimer() {
    const dateStr = getDayString();
    let data = getFullTimerData(state.worker, dateStr);

    // Znajdź ostatnią sesję (powinna być tylko jedna z isRunning==true lub żadna)
    let session = data.sessions && data.sessions.length ? data.sessions[data.sessions.length - 1] : null;
    if (!session) return;

    if (session.isRunning) {
        // STOP – wstrzymujemy licznik
        session.endTime = Date.now();
        session.isRunning = false;
        session.duration += Math.floor((session.endTime - session.startTime) / 1000);
        clearInterval(timerInterval);
        setFullTimerData(state.worker, dateStr, data);
    } else {
        // START – wznawiamy licznik
        session.startTime = Date.now();
        session.isRunning = true;
        setFullTimerData(state.worker, dateStr, data);
        timerInterval = setInterval(renderTimerSummary, 1000);
    }
    renderFullSummary();
    updateTimerButtonVisibility();
}


function renderFullSummary(workerOverride = null, dateStrOverride = null) {
  state.summaryDate = dateStrOverride || getDayString();

  const summary = document.getElementById('summary');
  summary.innerHTML = '';
  const worker = workerOverride || state.worker;
  const dateStr = dateStrOverride || getDayString();

  // Wpisy formularzowe (tylko z dzisiaj i tylko dla aktywnego użytkownika)
  const manualEntries = (state.worker === worker && dateStr === getDayString()) ? state.entries : [];

  // Timery z localStorage
  let timerData = getFullTimerData(worker, dateStr);
  let sessions = timerData.sessions || [];

  // Suma wszystkich sekund
  let totalSeconds = 0;

  // 1. Najpierw wpisy formularzowe (kafelki z godzinami)
  if (manualEntries.length > 0) {
    const container = document.createElement('div');
    container.className = 'summary-entry-container';
    manualEntries.forEach((e, i) => {
      totalSeconds += (typeof e.hours === "number" ? e.hours * 3600 : 0);
      const div = document.createElement('div');
      div.className = 'summary-entry';
      div.innerHTML = `
        <button class="remove-btn" onclick="removeEntry(${i})">❌</button>
        <p><strong>${e.project}</strong><br>${e.category} / ${e.subcategory}</p>
        <div class="hour-options">
          ${Array.from({length:16},(_,h)=> {
            const hv = h+1;
            return `<div class="tile ${e.hours===hv?'selected':''}" onclick="updateHours(${i},${hv})">${hv}</div>`;
          }).join('')}
        </div>
      `;
      container.appendChild(div);
    });
    summary.appendChild(container);
  }

  // 2. Potem wpisy z timera (każda sesja)
  let anySessionRunning = false;
  if (sessions.length > 0) {
    sessions.forEach((session, idx) => {
      let elapsed = session.duration || 0;
      if (session.isRunning) {
        elapsed += Math.floor((Date.now() - session.startTime) / 1000);
        anySessionRunning = true;
      }
      totalSeconds += elapsed;
      const h = Math.floor(elapsed / 3600);
      const m = Math.floor((elapsed % 3600) / 60);
      const s = elapsed % 60;
      const elapsedStr = [h, m, s].map(x => x.toString().padStart(2, '0')).join(':');

      let btns = '';
      if (session.isRunning) {
        btns += `<button onclick="pauseTimerSession(${idx},'${worker}','${dateStr}')">⏹️ Stop</button>`;
      } else {
        btns += `<button onclick="resumeTimerSession(${idx},'${worker}','${dateStr}')">▶️ Wznów</button>`;
      }
      btns += `<button onclick="deleteTimerSession(${idx},'${worker}','${dateStr}')" style="margin-left:8px;">❌ Usuń</button>`;

      summary.innerHTML += `
        <div class="summary-entry row-timer">
          <span class="timer-col project"><b>${session.project}</b></span>
          <span class="timer-col category">${session.category}</span>
          <span class="timer-col subcategory">${session.subcategory}</span>
          <span class="timer-col time" id="timer-value-${idx}">${elapsedStr}</span>
          <span class="timer-col button">${btns}</span>
        </div>
      `;
    });

    // Żywy licznik – jeśli coś jest aktywne
    if (sessions.some(s => s.isRunning)) {
      if (!window.__fullSummaryTimer) {
        window.__fullSummaryTimer = setInterval(() => renderFullSummary(worker, dateStr), 1000);
      }
    } else {
      if (window.__fullSummaryTimer) {
        clearInterval(window.__fullSummaryTimer);
        window.__fullSummaryTimer = null;
      }
    }
  }

  // 3. Suma wszystkich godzin na dole
  const totalSpan = document.getElementById('totalHours');
  if (totalSpan) {
    totalSpan.innerText = formatSecondsHMS(totalSeconds);
    totalSpan.className = `total-hours ${totalSeconds>9*3600?'red':'green'}`;
  }

  // --- KLUCZ: logika widoczności przycisku „Dodaj kolejny projekt” ---
  const btn = document.querySelector('button[onclick="addAnotherProject()"]');
  if (btn) {
    // Ukryj jeśli: timerMode i JAKIKOLWIEK session.isRunning === true
    btn.style.display = (timerMode && anySessionRunning) ? 'none' : '';
  }
}




function pauseTimerSession(idx, workerOverride = null, dateStrOverride = null) {
    const worker = workerOverride || state.worker;
    const dateStr = dateStrOverride || getDayString();
    let data = getFullTimerData(worker, dateStr);
    let session = data.sessions[idx];
    if (!session || !session.isRunning) return;

    // Zakończ czas dla tej sesji
    session.endTime = Date.now();
    session.isRunning = false;
    session.duration += Math.floor((session.endTime - session.startTime) / 1000);

    setFullTimerData(worker, dateStr, data);

    if (window.__fullSummaryTimer) {
      clearInterval(window.__fullSummaryTimer);
      window.__fullSummaryTimer = null;
    }

    renderFullSummary(worker, dateStr);
    updateTimerButtonVisibility();
}

function resumeTimerSession(idx, workerOverride = null, dateStrOverride = null) {
    const worker = workerOverride || state.worker;
    const dateStr = dateStrOverride || getDayString();
    let data = getFullTimerData(worker, dateStr);

    // Najpierw zatrzymaj każdą inną aktywną sesję (żeby zawsze była tylko jedna aktywna)
    data.sessions.forEach((s, i) => {
        if (s.isRunning) {
            s.endTime = Date.now();
            s.isRunning = false;
            s.duration += Math.floor((s.endTime - s.startTime) / 1000);
        }
    });

    // Wznów wskazaną sesję
    let session = data.sessions[idx];
    if (!session || session.isRunning) return;
    session.startTime = Date.now();
    session.isRunning = true;

    setFullTimerData(worker, dateStr, data);

    if (window.__fullSummaryTimer) clearInterval(window.__fullSummaryTimer);
    window.__fullSummaryTimer = setInterval(() => renderFullSummary(worker, dateStr), 1000);

    renderFullSummary(worker, dateStr);
    updateTimerButtonVisibility();
}

function deleteTimerSession(idx, workerOverride = null, dateStrOverride = null) {
    const worker = workerOverride || state.worker;
    const dateStr = dateStrOverride || getDayString();
    let data = getFullTimerData(worker, dateStr);
    if (!data.sessions) return;
    data.sessions.splice(idx, 1);

    // Jeśli nie ma żadnych sesji, wyłącz timerState
    if (data.sessions.length === 0) {
        data.timerState = "off";
        if (window.__fullSummaryTimer) {
            clearInterval(window.__fullSummaryTimer);
            window.__fullSummaryTimer = null;
        }
    }
    setFullTimerData(worker, dateStr, data);
    renderFullSummary(worker, dateStr);
    updateTimerButtonVisibility();
    showToast("Usunięto timer");
}






function startTaskTimer(entry) {
    stopCurrentTaskTimer(); // zamknij, jeśli coś już było

    // Pobierz dane z localStorage na dziś
    const dateStr = getDayString();
    let data = getFullTimerData(state.worker, dateStr);

    // Jeśli jest aktywna sesja — domknięcie czasu
    if (data.sessions && data.sessions.length && data.sessions[data.sessions.length-1].isRunning) {
        // zatrzymaj poprzednią
        const prev = data.sessions[data.sessions.length-1];
        prev.endTime = Date.now();
        prev.isRunning = false;
        prev.duration = Math.floor((prev.endTime - prev.startTime)/1000);
    }

    // Dodaj nową sesję
    const newSession = {
        ...entry,
        startTime: Date.now(),
        endTime: null,
        isRunning: true,
        duration: 0 // w sekundach
    };
    data.sessions = data.sessions || [];
    data.sessions.push(newSession);

    data.timerState = "inProgress";
    setFullTimerData(state.worker, dateStr, data);

    timerData = newSession; // trzymamy aktualny wpis

    // Ekran podsumowania
    showStep(5);

    // **NOWOŚĆ — automatyczny podgląd timera w podsumowaniu**
    if (window.__fullSummaryTimer) clearInterval(window.__fullSummaryTimer);
    window.__fullSummaryTimer = setInterval(() => renderFullSummary(), 1000);

    renderFullSummary(); // <- renderuj od razu, nie czekaj na kliknięcie!

    // Ukryj "Dodaj kolejny projekt" tylko gdy jest tryb timera
    const btn = document.querySelector('button[onclick="addAnotherProject()"]');
    if (btn) btn.style.display = timerMode ? 'none' : '';

    updateTimerButtonVisibility();
}




// obsługa przycisku
async function handleUpdateTasks() {
  if (!currentEntry?.category) return;
  const tasksByCat = await fetchTasksFromSheet();
  const list = Array.from(new Set([
    ...(subcategoriesMap[currentEntry.category]||[]),
    ...(tasksByCat[currentEntry.category]||[])
  ]));
  renderTiles('subcategories', list, subcat => {
    currentEntry.subcategory = subcat;
    document.getElementById('hourSection').style.display = 'block';
  });
  showToast("Zadania zaktualizowane");
}



    function renderHourTiles() {
      const c = document.getElementById('hourTiles');
      c.innerHTML = '';
      for (let i=1; i<=16; i++){
        const d = document.createElement('div');
        d.className = 'tile';
        d.innerText = i;
        d.onclick = () => {
          currentEntry.hours = i;
          tryFinishEntry();
        };
        c.appendChild(d);
      }
    }

    function tryFinishEntry() {
      if (currentEntry.subcategory && currentEntry.hours>0) {
        state.entries.push({ ...currentEntry });
        showStep(5);
        renderFullSummary();
      }
    }

    


    function removeEntry(idx) {
      state.entries.splice(idx,1);
      renderFullSummary();
    }
    function updateHours(idx,val) {
      state.entries[idx].hours = val;
      renderFullSummary();
    }

function addAnotherProject(){
    if (timerMode) {
        const dateStr = getDayString();
        let data = getFullTimerData(state.worker, dateStr);
        // Jeśli JAKIKOLWIEK timer jest isRunning – blokujemy dodanie nowego zadania
        if (data.sessions && data.sessions.some(s => s.isRunning)) {
            showToast("Najpierw zatrzymaj aktualny pomiar (STOP)", true);
            return;
        }
    }
    // Czyść licznik interwału po wyjściu z podsumowania
    if (window.__fullSummaryTimer) {
        clearInterval(window.__fullSummaryTimer);
        window.__fullSummaryTimer = null;
    }
    showStep(2);
    renderProjects();
}

function checkOvernightTimers(worker, dateStr) {
  // Pobierz dane timerów użytkownika
  const timerData = getFullTimerData(worker, dateStr);
  const sessions = timerData.sessions || [];

  const today = new Date().toDateString();

  // Przejdź po wszystkich aktywnych sesjach
  sessions.forEach((session, idx) => {
    if (session.isRunning) {
      const start = new Date(session.startTime);
      // Jeśli startTime to NIE dzisiejsza data:
      if (start.toDateString() !== today) {
        // Pokaż popup TYLKO raz na wejście!
        if (!window.__overnightPopupShown) {
          window.__overnightPopupShown = true;
          setTimeout(() => {
            if (confirm(
              "Wygląda na to, że timer został uruchomiony wczoraj (" +
              start.toLocaleString() +
              ").\nCzy chcesz zaliczyć cały czas do dzisiaj (co może dać zbyt wiele godzin), czy zakończyć timer wczoraj (i wpisać faktyczny czas zakończenia)?\n\nKliknij OK, aby zakończyć timer na koniec wczorajszego dnia, lub Anuluj, aby zostawić jak jest."
            )) {
              // Ustaw duration do końca dnia startu (np. 23:59:59)
              const endOfStartDay = new Date(start);
              endOfStartDay.setHours(23, 59, 59, 999);
              session.duration += Math.floor((endOfStartDay - start) / 1000);
              session.isRunning = false;
              session.startTime = null;
              saveFullTimerData(worker, dateStr, timerData);
              alert("Timer został zakończony na koniec dnia " + start.toLocaleDateString());
              renderFullSummary(worker, dateStr);
            }
            // Jeśli Anuluj, timer zostaje jak jest — może naliczyć 20h
          }, 100); // mały delay, by nie zblokować interfejsu
        }
      }
    }
  });
}


    // ————— ZAPIS DO SHEETS —————
    function submitData() {
      if (!gapiInited || !gisInited) {
        alert("Trwa inicjalizacja Google API, spróbuj za chwilę.");
        return;
      }
      const tok = gapi.client.getToken();
      if (!tok) {
        tokenClient.requestAccessToken({ prompt: '' });
      } else {
        actuallySubmitData();
      }
    }

   async function actuallySubmitData() {
  try {
    let values = [];
    // — normalne wpisy (nie-timerowe)
    if (state.entries && state.entries.length) {
      values = state.entries.map(e => [
        formatDateForSheets(new Date()),
        state.worker,
        e.project,
        e.category,
        e.subcategory,
        (typeof e.hours === "number") ? e.hours * 3600 : 0 // zamień na sekundy
      ]);
    }

    // — wpisy z timera:
    const dateStr = state.summaryDate || getDayString();
    let data = getFullTimerData(state.worker, dateStr);
    if (data.sessions && data.sessions.length) {
      data.sessions.forEach(s => {
        values.push([
          formatDateForSheets(new Date(s.startTime)),
          state.worker,
          s.project,
          s.category,
          s.subcategory,
          Math.floor(s.duration || 0) // SECONDS
        ]);
      });
      // UWAGA: NIE kasuj localStorage na tym etapie!
      // Kasujemy dopiero po sukcesie (poniżej)
    }

    if (!values.length) {
      showToast("Brak danych do zapisania!", true);
      return;
    }

    // ——— [NOWOŚĆ] ———
    // Przed próbą zapisu do Google Sheets — ZAPISZ dane do localStorage!
    localStorage.setItem("pendingSave", JSON.stringify({
      values,
      worker: state.worker,
      date: new Date().toISOString()
    }));

    // Próba zapisu do Google Sheets
    await gapi.client.sheets.spreadsheets.values.append({
      spreadsheetId: SPREADSHEET_ID,
      range: `${SHEET_NAME_SAVE}!A1`,
      valueInputOption: 'USER_ENTERED',
      insertDataOption: 'INSERT_ROWS',
      resource: { values }
    });

    // ——— PO SUKCESIE ———
    // Kasujemy zaległe dane, bo już są w arkuszu
    localStorage.removeItem("pendingSave");

    // Czyścimy dane timerów tylko jeśli się powiodło!
    localStorage.removeItem(getTimerStorageKey(state.worker, dateStr));
    // Usuń cache statusów, żeby przy resetForm() pobrać je na nowo
    localStorage.removeItem("workerStatusCache");

    resetForm();
    showToast("Dane zostały zapisane!");
  } catch (err) {
    console.error("Błąd zapisu:", err);
    // NIE kasujemy pendingSave! Dane zostają na następną próbę.
    showToast("Błąd zapisu! Twoje dane są zachowane. Spróbuj ponownie.", true);
  }
}




    // ————— ZAMIENNIK fetchProjectsFromSheet —————
async function fetchProjectsFromSheet() {
  if (!gapiInited) return;
  try {
    const [base, custom] = await Promise.all([
      withAuthRequest(() =>
        gapi.client.sheets.spreadsheets.values.get({
          spreadsheetId: SPREADSHEET_ID,
          range: `${SHEET_NAME_LOAD}!A2:A`
        })
      ),
      withAuthRequest(() =>
        gapi.client.sheets.spreadsheets.values.get({
          spreadsheetId: SPREADSHEET_ID,
          range: `NoweProjekty!A2:A`
        })
      )
    ]);
    const baseList   = base.result.values?.flat()   || [];
    const customList = custom.result.values?.flat() || [];
    window.projects = Array.from(new Set([...baseList, ...customList].filter(Boolean)));
    setCachedProjects(window.projects);
    renderProjects(); 
    showToast("Projekty zaktualizowane");
  } catch (e) {
    console.error("Błąd pobierania projektów:", e);
    showToast("Błąd pobierania projektów", true);
  }
}


// ————— NOWA funkcja pobierająca zadania z arkusza NoweZadania —————
async function fetchSubcategoriesFromSheet(category) {
  if (!gapiInited) return [];
  try {
    const res = await gapi.client.sheets.spreadsheets.values.get({
      spreadsheetId: SPREADSHEET_ID,
      range: `NoweZadania!A2:B`
    });
    const rows = res.result.values || [];
    return rows
      .filter(row => row[0] === category && row[1])
      .map(row => row[1]);
  } catch (e) {
    console.error("Błąd pobierania nowych zadań:", e);
    return [];
  }
}


function formatDateForSheets(date) {
  const pad = n => n.toString().padStart(2, '0');
  return `${date.getFullYear()}-${pad(date.getMonth()+1)}-${pad(date.getDate())} ${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}`;
}

const TIMER_USERS = ["Kamil", "Paweł"];

function getDayString(offset = 0) {
    const d = new Date();
    d.setDate(d.getDate() + offset);
    return d.toISOString().split('T')[0];
}




// Obiekt z sesjami — zapisujemy pod kluczem timerData_<worker>_<data>
function getFullTimerData(worker, dateStr) {
    const key = getTimerStorageKey(worker, dateStr);
    return JSON.parse(localStorage.getItem(key) || '{"sessions":[],"timerState":"off"}');
}

function setFullTimerData(worker, dateStr, data) {
    const key = getTimerStorageKey(worker, dateStr);
    localStorage.setItem(key, JSON.stringify(data));
}

function checkOvernightTimer(worker) {
  const now = new Date();
  const todayStr = getDayString();
  const timers = loadTimerDataForWorker(worker);

  for (const { dayStr, data } of timers) {
    if (!data.sessions || !data.sessions.length) continue;
    for (const session of data.sessions) {
      if (session.isRunning && session.startTime) {
        const sessionDate = new Date(session.startTime);
        const sessionDayStr = sessionDate.toISOString().split('T')[0];
        if (sessionDayStr !== todayStr) {
          // Timer zaczął się innego dnia!
          showOvernightTimerPopup({ worker, dayStr, session });
          return true; // znalazło i pokazało popup, kończymy
        }
      }
    }
  }
  return false; // nie znaleziono
}

function showOvernightTimerPopup({worker, dayStr, session}) {
  const startDate = new Date(session.startTime);
  const now = new Date();
  const elapsed = Math.floor((now - startDate) / 1000);
  const h = Math.floor(elapsed / 3600);
  const m = Math.floor((elapsed % 3600) / 60);
  const s = elapsed % 60;
  const elapsedStr = [h, m, s].map(x => x.toString().padStart(2, '0')).join(':');

  // Prosty modal
  const html = `
    <div id="overnight-popup" style="position:fixed;top:16%;left:50%;transform:translateX(-50%);
      background:white;padding:24px 18px;box-shadow:0 0 20px #0003;z-index:9999;border-radius:16px;max-width:330px">
      <h3>Wykryto timer z poprzedniego dnia!</h3>
      <p>
        Timer rozpoczęty: <b>${startDate.toLocaleString()}</b><br>
        Aktualny czas: <b>${now.toLocaleString()}</b><br>
        <b>Łączny czas:</b> ${elapsedStr}
      </p>
      <button onclick="acceptOvernightTimer('${worker}','${dayStr}')">
        Zakończ timer i zapisz cały czas (${elapsedStr})
      </button>
      <button style="margin-left:12px" onclick="editOvernightTimer('${worker}','${dayStr}','${session.startTime}')">
        Podaj ręcznie godzinę zakończenia
      </button>
      <br><br>
      <button class="back-button" onclick="closeOvernightPopup()">Anuluj</button>
    </div>
  `;
  document.getElementById('overnight-popup')?.remove();
  const div = document.createElement('div');
  div.innerHTML = html;
  document.body.appendChild(div);
}

function closeOvernightPopup() {
  document.getElementById('overnight-popup')?.remove();
}

function acceptOvernightTimer(worker, dayStr) {
  let data = getFullTimerData(worker, dayStr);
  let session = (data.sessions||[]).find(s => s.isRunning);
  if (!session) return;
  session.endTime = Date.now();
  session.duration += Math.floor((session.endTime - session.startTime)/1000);
  session.isRunning = false;
  setFullTimerData(worker, dayStr, data);
  closeOvernightPopup();
  showToast("Timer zakończony – możesz go teraz zapisać");
  showStep(5);
  renderOldTimerSummary(worker, dayStr);
}

function editOvernightTimer(worker, dayStr, startTime) {
  const val = prompt("Podaj godzinę zakończenia (HH:MM, np. 18:30):", "18:00");
  if (!val) return;
  const [hh, mm] = val.split(':').map(Number);
  if (isNaN(hh) || isNaN(mm)) {
    showToast("Nieprawidłowy format godziny!", true);
    return;
  }
  let endDate = new Date(Number(startTime));
  endDate.setHours(hh, mm, 0, 0);
  let endTime = endDate.getTime();
  if (endTime < startTime) endTime += 24*3600*1000; // na wypadek przekroczenia północy

  let data = getFullTimerData(worker, dayStr);
  let session = (data.sessions||[]).find(s => s.isRunning);
  if (!session) return;
  session.endTime = endTime;
  session.duration += Math.floor((endTime - session.startTime)/1000);
  session.isRunning = false;
  setFullTimerData(worker, dayStr, data);
  closeOvernightPopup();
  showToast("Czas poprawiony – możesz go teraz zapisać");
  showStep(5);
  renderOldTimerSummary(worker, dayStr);
}


function updateTimerButtonVisibility() {
    const btn = document.getElementById('timer-toggle-btn');
    if (!state.worker || !TIMER_USERS.includes(state.worker)) {
        btn.style.display = 'none';
        return;
    }
    btn.style.display = 'inline-block';

    const dateStr = getDayString();
    const data = getFullTimerData(state.worker, dateStr);
    // Żółty — gdy jest choć jedna sesja niezapisana lub trwa
    const anyActive = (data.sessions||[]).some(s => s.isRunning || !s.savedToSheet);
    let timerState = data.timerState || "off";

    if (anyActive) timerState = "inProgress"; // lub "yellow"
    btn.textContent = (timerState === 'on' ? "⏱ Timer: ON" :
                      timerState === 'off' ? "⏱ Timer: OFF" :
                      "⏱ Timer: W TRAKCIE");
    btn.style.background = timerState === 'on' ? "#28a745" : 
                          timerState === 'off' ? "#d80000" : "#ffc107";
    btn.style.color = (timerState === 'on' || timerState === 'off') ? "#fff" : "#222";
}


function handleTimerToggle() {
    if (!state.worker || !TIMER_USERS.includes(state.worker)) return;

    const dateStr = state.summaryDate || getDayString();
    const data = getFullTimerData(state.worker, dateStr);

    // Czy jest aktywna jakakolwiek sesja?
    const anyActive = (data.sessions||[]).some(s => s.isRunning);

    let timerState = getTimerState(state.worker);

    if (timerState === "off") {
        // Włącz tryb timera
        timerState = "on";
        timerMode = true;
        showToast("Tryb timera WŁĄCZONY");
    } else if (timerState === "on" || timerState === "inProgress") {
        // Jeśli jest aktywny timer – NIE pozwalaj wyłączyć trybu!
        if (anyActive) {
            showToast("Najpierw zatrzymaj wszystkie aktywne timery!", true);
            return;
        }
        // Wyłącz tryb timera (i pozwól na manual)
        timerState = "off";
        timerMode = false;
        showToast("Tryb timera WYŁĄCZONY – możesz dodawać ręczne wpisy");
    }

    saveTimerState(state.worker, timerState);
    updateTimerButtonVisibility();
    renderFullSummary();
}


function goToSummary() {
  showStep(5);
  if (timerMode) renderFullSummary();
  else renderFullSummary();
}



    // ————— START ————
  </script>
<!-- Eruda: <script src="https://cdn.jsdelivr.net/npm/eruda"></script> < --konsola na urządzeniach mobilnych -->
<script>
  document.addEventListener('DOMContentLoaded', () => {
    eruda.init({
      // które narzędzia pokazać
      tool: ['console', 'elements', 'network', 'resources'],
      // domyślne opcje
      defaults: {
        // automatycznie pokaż panel po init()
        autoShow: true,
        // procent wysokości ekranu dla panelu
        displaySize: 40
      }
    });
    // wymuszone otwarcie
    eruda.show();
  });
gapiLoaded();
gisLoaded();
</script>


</body>
</html>
