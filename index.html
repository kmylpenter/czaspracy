<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8">
  <title>Rejestracja czasu pracy</title>

 <script src="https://apis.google.com/js/api.js"></script>
<script src="https://accounts.google.com/gsi/client"></script>


  <style>

:root {
  --main-bg: #f3f7fa;
  --accent1: #3a86ff;
  --accent1-light: #e0eeff;
  --accent2: #f9a826;
  --glass-bg: rgba(255,255,255,0.55);
  --glass-blur: blur(8px);
  --border: 1.5px solid rgba(60, 70, 100, 0.10);
  --tile-radius: 18px;
  --shadow1: 0 8px 32px rgba(60,70,100,0.08);
  --shadow2: 0 2px 12px rgba(60,70,100,0.07);
  --error: #d80000;
  --green: #1dd1a1;
  --yellow: #ffd600;
}

/* ‚Äî‚Äî‚Äî‚Äî GLOBAL ‚Äî‚Äî‚Äî‚Äî */
body {
  font-family: 'Segoe UI', 'Montserrat', Arial, sans-serif;
  margin: 0;
  padding: 0;
  background: var(--main-bg);
  color: #222;
  display: flex;
  flex-direction: column;
  align-items: center;
  min-height: 100vh;
}
body::after {
  content: "";
  position: fixed;
  top: 0; left: 0;
  width: 100vw; height: 100vh;
  background: url('https://raw.githubusercontent.com/kmylpenter/czaspracy/main/Finalkmylpenter_3.0_trademark_final.png') no-repeat center center;
  background-size: contain;
  opacity: 0.03;
  pointer-events: none;
  z-index: 0;
}

#clock {
  font-size: 1.18rem;
  letter-spacing: 0.06em;
  font-weight: 500;
  margin-bottom: 0;
  margin-top: 16px;
  color: var(--accent1);
  text-shadow: 0 1px 1px rgba(58,134,255,0.06);
  text-align: center;
  width: 100vw;
}
h2 {
  font-size: 2rem;
  margin-top: 26px;
  margin-bottom: 8px;
  text-align: center;
  width: 100vw;
}
h3 {
  margin: 20px 0 0 0;
}

.screen {
  display: none;
  flex-direction: column;
  align-items: center;
  width: 100%;
}
.active {
  display: flex;
}

.nav-bar {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 10px;
  padding: 10px;
  position: static;
  width: 100%;
  box-sizing: border-box;
}

/* ‚Äî‚Äî‚Äî‚Äî TILES / GRID ‚Äî‚Äî‚Äî‚Äî */
.grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
  gap: 10px;
  margin: 20px;
  width: 90%;
  max-width: 800px;
  justify-content: center;
  justify-items: center;
}
@media (max-width: 650px) {
  .grid { font-size:0.95rem; gap:8px;}
}
@media (max-width: 400px) {
  .grid {
    grid-template-columns: 1fr !important;
    justify-content: center;
    justify-items: center;
  }
}

.tile {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  width: 100px;
  height: 70px;
  white-space: normal;
  word-break: break-word;
  text-align: center;
  padding: 10px;
  border-radius: var(--tile-radius);
  box-shadow: var(--shadow2);
  cursor: pointer;
  transition: all 0.18s cubic-bezier(.6,1.5,.45,1);
  border: var(--border);
  background: var(--glass-bg);
  backdrop-filter: var(--glass-blur);
  font-weight: 500;
  margin: 0;
  position: relative;
}
.tile:hover {
  background: var(--accent1-light);
  transform: scale(1.06) translateY(-1px);
  box-shadow: 0 6px 24px rgba(60,70,100,0.12);
}
.tile.selected {
  background: var(--accent1-light);
  border: 2px solid var(--accent1);
  box-shadow: 0 0 0 2px var(--accent1-light);
}
.tile.clicked { animation: pop 0.22s ease-out; }
@keyframes pop {
  0%   { transform: scale(1);}
  50%  { transform: scale(1.08);}
  100% { transform: scale(1);}
}
/* Kafle w poszczeg√≥lnych krokach */
.tile-step1 { background: var(--glass-bg);}
.tile-step2 { background: var(--glass-bg);}
.tile-step3 { background: var(--glass-bg);}
.tile-step4 { background: var(--glass-bg) !important;}
/* Kolory status√≥w */
.tile-status-green  { background: #d4edda !important; border: 2px solid #28a745;}
.tile-status-yellow { background: #fff3cd !important; border: 2px solid #ffc107;}
.tile-status-red    { background: #f8d7da !important; border: 2px solid #dc3545;}
/* Ostatnio u≈ºywane */
.tile.recent {
  background: #fffbe6 !important;
  border: 2px dashed #ffc107;
}

/* Kafelki z godzinami (ma≈Çe) */
#step5 .hour-options .tile,
#hourTiles .tile {
  width: 50px;
  height: 50px;
  padding: 5px;
  font-size: 1rem;
}

/* ‚Äî‚Äî‚Äî‚Äî BUTTONS ‚Äî‚Äî‚Äî‚Äî */
button, .back-button {
  margin: 10px;
  padding: 12px 28px;
  font-size: 1.12rem;
  cursor: pointer;
  border: none;
  border-radius: 10px;
  background: var(--accent1);
  color: #fff;
  transition: background 0.15s, box-shadow 0.15s;
  box-shadow: 0 2px 6px rgba(60,70,100,0.10);
  font-weight: 500;
  letter-spacing: 0.03em;
  outline: none;
  position: relative;
  z-index: 1;
}
button:hover, .back-button:hover {
  background: #5aa0ff;
}
.back-button {
  background: #e0e0e0;
  color: #333;
  box-shadow: none;
}
.back-button:hover {
  background: #d0d0d0;
  color: #222;
}

/* Lepsze guziki na podsumowaniu */
#step5 button {
  margin: 12px 12px 0 0;
  padding: 14px 34px;
  font-size: 1.12rem;
  min-width: 130px;
  min-height: 48px;
  white-space: nowrap;
}
#step5 button:last-child { margin-right: 0; }
@media (max-width: 600px) {
  #step5 button {
    width: 100%;
    margin: 10px 0 0 0;
    display: block;
    font-size: 1rem;
    padding: 16px 0;
    min-width: unset;
  }
}

/* Przycisk X do usuwania */
.remove-btn {
  float: right;
  background: none !important;
  border: none;
  font-size: 1.25rem;
  color: var(--error);
  cursor: pointer;
  margin-top: -8px;
  margin-right: -8px;
  padding: 0;
  transition: color 0.16s;
}
.remove-btn:hover { color: #ff0000; }

/* ‚Äî‚Äî‚Äî‚Äî TIMER ‚Äî‚Äî‚Äî‚Äî */
.summary-entry.row-timer {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 16px;
  padding: 10px 10px;
  margin: 8px 0;
  background: var(--glass-bg);
  border-radius: 8px;
  box-shadow: var(--shadow2);
  font-size: 1.02rem;
  border: var(--border);
  backdrop-filter: var(--glass-blur);
}
.timer-col.project   { min-width: 80px; font-weight: bold; }
.timer-col.category  { min-width: 80px; }
.timer-col.subcategory { min-width: 100px; }
.timer-col.time      { min-width: 80px; font-family: 'Consolas', monospace; }
.timer-col.button    { margin-left: auto; }
@media (max-width: 650px) {
  .summary-entry.row-timer { flex-wrap: wrap; font-size:0.95rem; gap:8px;}
  .timer-col.project, .timer-col.category, .timer-col.subcategory, .timer-col.time { min-width:unset;}
}

/* ‚Äî‚Äî‚Äî‚Äî PODSUMOWANIE ‚Äî‚Äî‚Äî‚Äî */
.summary-entry {
  margin: 10px 0;
  padding: 10px;
  background: var(--glass-bg);
  border-radius: 10px;
  box-shadow: var(--shadow2);
  border: var(--border);
  position: relative;
}
.summary-entry-container {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 16px;
  justify-content: center;
  max-width: 800px;
  margin: 20px auto;
}
@media (max-width: 800px) {
  .summary-entry-container {
    grid-template-columns: 1fr;
    width: 98vw;
    margin: 6px 0;
  }
}

/* ≈ÅƒÖczna liczba godzin */
.total-hours {
  font-size: 2.5rem;
  font-weight: bold;
  margin-left: 20px;
}
.total-hours.red { color: var(--error);}
.total-hours.green { color: var(--green);}

/* ‚Äî‚Äî‚Äî‚Äî GODZINY ‚Äî‚Äî‚Äî‚Äî */
.hour-options {
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  gap: 10px;
  margin-top: 10px;
  width: 90%;
  max-width: 800px;
}
@media (max-width: 650px) {
  .hour-options { grid-template-columns: repeat(4, 1fr);}
}
@media (max-width: 400px) {
  .hour-options { grid-template-columns: repeat(2, 1fr);}
}

/* Ukryj wyb√≥r godzin na wej≈õciu do kroku 4 */
#hourSection { display: none; }

/* ‚Äî‚Äî‚Äî‚Äî POPUPY I TOAST ‚Äî‚Äî‚Äî‚Äî */
#toast {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  background: var(--green);
  color: white;
  padding: 10px 24px;
  border-radius: 12px;
  font-size: 1.04rem;
  display: none;
  z-index: 9999;
  box-shadow: 0 2px 18px rgba(60,70,100,0.14);
  font-weight: 500;
}
#toast.error {
  background: var(--error);
}

/* Edycja wpis√≥w: styl tabelki */
#entries-popup table {
  font-size: 0.94rem;
  border-collapse: collapse;
  width: 100%;
  background: var(--glass-bg);
  backdrop-filter: var(--glass-blur);
  border-radius: 10px;
  overflow: hidden;
}
#entries-popup table th,
#entries-popup table td {
  border: 1px solid #eee;
  padding: 6px;
  text-align: left;
}
#entries-popup table th {
  background: var(--accent1-light);
}
#entries-popup table td > button {
  padding: 0;
  margin: 0;
  line-height: 1;
  font-size: inherit;
  background: none;
  border: none;
  cursor: pointer;
  vertical-align: middle;
}
#entries-popup h3 { margin-top: 0; }

/* Inne poprawki */
#recent-projects-container, #all-projects-container {
  width: 90%;
  max-width: 800px;
  margin-top: 20px;
  background: none;
}
#subcategories {
  background: none !important;
}


    
  </style>
</head>
<body>
<h3 id="clock" style="margin-top: 0;"></h3>
<div id="toast"></div>

 <div class="nav-bar" id="backButtonContainer">
  <button class="back-button" id="backBtn" onclick="goBack()">‚¨Ö Wstecz</button>
  <button id="addBtn" class="back-button" style="margin-left: 10px;" onclick="handleAddCustom()">‚ûï Dodaj</button>
  <button class="back-button" id="viewEntriesBtn" onclick="showRecentEntries()">üìã Zobacz wpisy</button>
  <button id="timer-toggle-btn" onclick="handleTimerToggle()" style="display:none; margin-left:10px;">‚è± Timer</button>
  <button id="go-summary-btn" class="back-button" onclick="goToSummary()" style="display:none;">üìä Podsumowanie</button>
</div>




  <h2 id="step-title">Jak masz na imiƒô?</h2>

  <div class="screen active" id="step1">
    <div class="grid" id="workers"></div>
  </div>
<div class="screen" id="step2">

  <button onclick="fetchProjectsFromSheet()">üîÑ Aktualizuj projekty</button>

  <!-- Sekcja ostatnio u≈ºywane -->
  <div id="recent-projects-container" style="width:90%; max-width:800px; margin-top:20px;">
    <h3>Ostatnio u≈ºywane:</h3>
    <div class="grid" id="recent-projects"></div>
  </div>

  <!-- Sekcja wszystkie projekty -->
  <div id="all-projects-container" style="width:90%; max-width:800px; margin-top:20px;">
    <h3>Wszystkie projekty:</h3>
    <div class="grid" id="projects"></div>
  </div>
</div>


  <div class="screen" id="step3">
<button onclick="fetchCategoriesFromSheet()">üîÑ Aktualizuj kategorie</button>
    <div class="grid" id="categories"></div>
    <div id="add-category-container" style="text-align:center;">
         </div>

  </div>
 <div class="screen" id="step4">
  <!-- ‚û°Ô∏è tutaj przycisk od≈õwie≈ºania zada≈Ñ -->
  <div id="task-update-container" style="width:90%; max-width:800px; margin-bottom:10px; text-align:center;">
    <button onclick="handleUpdateTasks()">üîÑ Aktualizuj zadania</button>
  </div>

  <!-- lista kafelk√≥w z zadaniami -->
  <div class="grid tile-step4" id="subcategories"></div>

  <!-- wyb√≥r godzin -->
  <div id="hourSection" style="display:none;">
    <h3>Wybierz liczbƒô godzin:</h3>
    <div class="hour-options" id="hourTiles"></div>
  </div>
</div>
  <div class="screen" id="step5">
    <div id="summary"></div>
    <p><strong>≈ÅƒÖczna liczba godzin:</strong> <span id="totalHours">0</span> h</p>
    <button onclick="addAnotherProject()">Dodaj kolejny projekt</button>
    <button onclick="resetForm()">Zacznij od nowa</button>
    <button onclick="submitData()">Zapisz</button>
  </div>

  <script>
// Wstaw do funkcji updateTimerButtonVisibility:
function updateTimerButtonVisibility() {
    const btn = document.getElementById('timer-toggle-btn');
    if (!state.worker || !TIMER_USERS.includes(state.worker)) {
        btn.style.display = 'none';
        return;
    }
    btn.style.display = 'inline-block';

    // UWAGA! Bierz datƒô ze state.summaryDate je≈õli istnieje
    const dateStr = state.summaryDate || getDayString();
    const data = getFullTimerData(state.worker, dateStr);
    const anyActive = (data.sessions||[]).some(s => s.isRunning || !s.savedToSheet);
    let timerState = data.timerState || "off";
    if (anyActive) timerState = "inProgress"; // lub "yellow"

    btn.textContent = (timerState === 'on' ? "‚è± Timer: ON" :
                      timerState === 'off' ? "‚è± Timer: OFF" :
                      "‚è± Timer: W TRAKCIE");
    btn.style.background = timerState === 'on' ? "#28a745" : 
                          timerState === 'off' ? "#d80000" : "#ffc107";
    btn.style.color = (timerState === 'on' || timerState === 'off') ? "#fff" : "#222";
}


// Pokazuje/ukrywa przycisk "Podsumowanie" gdy aktywny tryb timera
function updateSummaryButtonVisibility() {
  const btn = document.getElementById('go-summary-btn');
  btn.style.display = timerMode ? 'inline-block' : 'none';
}

// ‚Äî‚Äî‚Äî‚Äî UNIWERSALNY WRAPPER Z LOGOWANIEM GOOGLE ‚Äî‚Äî‚Äî‚Äî
async function withAuthRequest(fn) {
  try {
    // 1. Je≈õli nie mamy tokena, popro≈õ o dostƒôp
    if (!gapi.client.getToken()) {
      await new Promise((resolve, reject) => {
        tokenClient.callback = (resp) => {
          if (resp.error) reject(resp.error);
          else resolve();
        };
        tokenClient.requestAccessToken({ prompt: '' });
      });
    }
    // 2. Spr√≥buj wywo≈Çaƒá przekazanƒÖ funkcjƒô
    return await fn();
  } catch (e) {
    // 3. Je≈õli b≈ÇƒÖd autoryzacji ‚Äì spr√≥buj jeszcze raz po zalogowaniu
    if (
      e.status === 401 ||
      e.status === 403 ||
      (e.result && e.result.error && e.result.error.code === 401)
    ) {
      await new Promise((resolve, reject) => {
        tokenClient.callback = (resp) => {
          if (resp.error) reject(resp.error);
          else resolve();
        };
        tokenClient.requestAccessToken({ prompt: '' });
      });
      return await fn();
    } else {
      throw e;
    }
  }
}


// Funkcja prze≈ÇƒÖczajƒÖca timer po klikniƒôciu
function handleTimerToggle() {
    if (!state.worker || !TIMER_USERS.includes(state.worker)) return;
    let timerState = getTimerState(state.worker);
    if (timerState === "off") timerState = "on";
    else if (timerState === "on") timerState = "off";
    // inProgress ustawiamy tylko w p√≥≈∫niejszych krokach
    saveTimerState(state.worker, timerState);
    updateTimerButtonVisibility();
}


// ‚Äî‚Äî‚Äî‚Äì KONFIGURACJA TIMERA ‚Äî‚Äî‚Äî‚Äî
const TIMER_STORAGE_PREFIX = "timerData_";
const TIMER_DAYS_BACK = 3;

// Zwraca datƒô w formacie YYYY-MM-DD
function getDayString(offsetDays = 0) {
  const d = new Date();
  d.setDate(d.getDate() - offsetDays);
  return d.toISOString().split('T')[0];
}

// Generuje klucz do localStorage dla danego u≈ºytkownika i daty
function getTimerStorageKey(worker, dateString) {
  return `${TIMER_STORAGE_PREFIX}${worker}_${dateString}`;
}

// Odczytaj dane z localStorage dla u≈ºytkownika z ostatnich 3 dni
function loadTimerDataForWorker(worker) {
  const results = [];
  for (let i = 0; i < TIMER_DAYS_BACK; i++) {
    const dayStr = getDayString(i);
    const key = getTimerStorageKey(worker, dayStr);
    const dataStr = localStorage.getItem(key);
    if (dataStr) {
      try {
        const data = JSON.parse(dataStr);
        results.push({ dayStr, data });
      } catch(e) {
        // Je≈õli co≈õ jest nie tak ‚Äì usu≈Ñ z localStorage
        localStorage.removeItem(key);
      }
    }
  }
  return results;
}

// Zapisuje dane timera dla u≈ºytkownika i danego dnia
function saveTimerDataForWorker(worker, dateString, timerData) {
  const key = getTimerStorageKey(worker, dateString);
  localStorage.setItem(key, JSON.stringify(timerData));
}

// Usuwa dane timera po zapisaniu do arkusza
function clearTimerDataForWorker(worker, dateString) {
  localStorage.removeItem(getTimerStorageKey(worker, dateString));
}

// 1. Funkcja konwertujƒÖca sekundy na "xh ymin"
function formatSecondsToHhMm(sec) {
  sec = parseInt(sec, 10);
  if (isNaN(sec) || sec < 0) return "-";
  const h = Math.floor(sec / 3600);
  const m = Math.floor((sec % 3600) / 60);
  let out = "";
  if (h > 0) out += `${h}h `;
  if (m > 0) out += `${m}min`;
  if (out.trim() === "") out = "0min";
  return out.trim();
}


function showPendingTimersScreen(oldTimers, worker) {
  // Ukrywamy wszystkie ekrany
  document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
  // Tworzymy popup
  let html = `<div id="pending-timers-screen" style="
      position:fixed; top:10%; left:50%; transform:translateX(-50%);
      background:white; padding:30px; box-shadow:0 0 12px rgba(0,0,0,.20);
      max-width:350px; z-index:9999; border-radius:15px;">
      <h3>Masz niezapisane pomiary czasu z poprzednich dni:</h3>
      <ul style="padding-left:18px;">`;
  oldTimers.forEach(({dayStr, data}) => {
    html += `<li style="margin-bottom: 10px;">
      <b>${dayStr}</b> ‚Äî 
      <button onclick="viewPendingTimerSummary('${worker}','${dayStr}')" style="background:#3a86ff; color:white;">Wy≈õwietl</button>
      <br>
      <span style="font-size:0.95em; color:#666;">(Ilo≈õƒá wpis√≥w: ${data.entries ? data.entries.length : 0})</span>
    </li>`;
  });
  html += `</ul>
      <button onclick="skipAndClearPendingTimers('${worker}')" style="margin-top:12px; background:#d80000; color:white;">Pomi≈Ñ</button>
    </div>`;
  const div = document.createElement('div');
  div.innerHTML = html;
  document.body.appendChild(div);
}


function closePendingTimersScreen() {
  const el = document.getElementById('pending-timers-screen');
  if (el) el.remove();
  showStep(2);
  renderProjects();
  updateTimerButtonVisibility();
}
function saveOldTimerToSheet(worker, dayStr) {
  // Na razie tylko usuwamy dane (mock)
  clearTimerDataForWorker(worker, dayStr);
  // Usuwamy z ekranu zapisany wpis
  const el = document.getElementById('pending-timers-screen');
  if (el) el.remove();
  // Sprawdzamy, czy sƒÖ jeszcze jakie≈õ zaleg≈Çe
  const oldTimers = loadTimerDataForWorker(worker);
  if (oldTimers.length > 0) {
    showPendingTimersScreen(oldTimers, worker);
  } else {
    showStep(2);
    renderProjects();
    updateTimerButtonVisibility();
  }
  showToast("Zapisano (symulacja)");
}


// ‚Äî‚Äî‚Äî‚Äî‚Äî ZAMIENNIK showRecentEntries ‚Äî‚Äî‚Äî‚Äî‚Äî
async function showRecentEntries() {
  try {
    const now = new Date();
    const oneWeekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);

    const res = await withAuthRequest(() =>
      gapi.client.sheets.spreadsheets.values.get({
        spreadsheetId: SPREADSHEET_ID,
        range: `${SHEET_NAME_SAVE}!A2:F`,
      })
    );
    const allEntries = res.result.values || [];
    const enriched = allEntries.map((row, i) => ({
      data: row,
      rowIndex: i + 2
    }));

    const recent = enriched.filter(obj => {
      const d = new Date(obj.data[0]);
      return !isNaN(d) && d >= oneWeekAgo;
    });

    // 4) budujemy tabelƒô z dodatkowƒÖ kolumnƒÖ ‚ÄûEdytuj‚Äù
    const html = `
  <div id="entries-popup" style="position:fixed; top:10%; left:50%; transform:translateX(-50%);
              background:white; padding:20px; box-shadow:0 0 10px rgba(0,0,0,0.3);
              max-height:80vh; overflow:auto; z-index:9999; border-radius:12px;">
    <h3>Ostatnie wpisy</h3>
    <table style="font-size:0.8rem; border-collapse:collapse; width:100%;">
      <thead>
        <tr>
          <th>Data</th>
          <th>Pracownik</th>
          <th>Projekt</th>
          <th>Kategoria</th>
          <th>Zadanie</th>
          <th>Godziny</th>
          <th>Edytuj</th>
          <th>Usu≈Ñ</th>
        </tr>
      </thead>
      <tbody>
        ${recent.map(obj => `
          <tr>
            ${obj.data.map((col, colIdx) =>
              `<td>${colIdx === 5 ? formatSecondsToHhMm(col) : col}</td>`
            ).join('')}
            <td>
              <button onclick="editEntry(${obj.rowIndex})">‚úèÔ∏è</button>
            </td>
            <td>
              <button onclick="deleteEntry(${obj.rowIndex})" style="color:red;">üóëÔ∏è</button>
            </td>
          </tr>
        `).join('')}
      </tbody>
    </table>
    <div style="text-align:center; margin-top:10px;">
      <button onclick="document.getElementById('entries-popup').remove()">Zamknij</button>
    </div>
  </div>
`;

    // wstrzykniƒôcie
    const container = document.createElement('div');
    container.innerHTML = html;
    document.body.appendChild(container);

  } catch (e) {
    console.error("B≈ÇƒÖd pobierania wpis√≥w:", e);
    showToast("Nie uda≈Ço siƒô pobraƒá wpis√≥w", true);
  }
}
// Helpers: dostajesz i zapisujesz listƒô projekt√≥w w localStorage
function getCachedProjects() {
  try { return JSON.parse(localStorage.getItem('projekty')||'[]') }
  catch { return [] }
}
function setCachedProjects(arr) {
  localStorage.setItem('projekty', JSON.stringify(arr))
}




function viewPendingTimerSummary(worker, dayStr) {
  // Zamknij popup
  const el = document.getElementById('pending-timers-screen');
  if (el) el.remove();

  // Przejd≈∫ do ekranu podsumowania
  showStep(5);

  // Wy≈õwietl podsumowanie timera dla wybranej daty i pracownika
  renderTimerSummary(worker, dayStr);
}


function skipAndClearPendingTimers(worker) {
  // Usu≈Ñ wszystkie zaleg≈Çe timery z localStorage
  for (let i = 0; i < 3; i++) {
    const dayStr = getDayString(-i);
    const key = getTimerStorageKey(worker, dayStr);
    localStorage.removeItem(key);
  }
  // Zamknij popup
  const el = document.getElementById('pending-timers-screen');
  if (el) el.remove();
  showStep(2);
  renderProjects();
  updateTimerButtonVisibility();
  showToast("Wyczyszczono niezatwierdzone pomiary", false);
}

function renderOldTimerSummary(worker, dayStr) {
  state.summaryDate = dayStr;
  renderFullSummary(worker, dayStr);
}




function getCachedTasks() {
  try { return JSON.parse(localStorage.getItem('tasksCache')||'{}') }
  catch { return {} }
}
function setCachedTasks(obj) {
  localStorage.setItem('tasksCache', JSON.stringify(obj))
}

// pobierz WSZYSTKIE zadania raz z arkusza, pogrupuj po kategorii
async function fetchTasksFromSheet() {
  if (!gapiInited) return {};
  try {
    const res = await withAuthRequest(() =>
      gapi.client.sheets.spreadsheets.values.get({
        spreadsheetId: SPREADSHEET_ID,
        range: `NoweZadania!A2:B`
      })
    );
    const rows = res.result.values || [];
    const tasksByCat = {};
    rows.forEach(([cat, task]) => {
      if (cat && task) {
        if (!tasksByCat[cat]) tasksByCat[cat] = [];
        if (!tasksByCat[cat].includes(task)) tasksByCat[cat].push(task);
      }
    });
    setCachedTasks(tasksByCat);
    if (currentStep === 4 && currentEntry?.category) {
      const list = tasksByCat[currentEntry.category] || [];
      renderTiles('subcategories', list, subcat => {
        currentEntry.subcategory = subcat;
        document.getElementById('hourSection').style.display = 'block';
      });
    }
    showToast("Zadania zaktualizowane z arkusza");
    return tasksByCat;
  } catch (e) {
    console.error("B≈ÇƒÖd pobierania zada≈Ñ:", e);
    showToast("B≈ÇƒÖd aktualizacji zada≈Ñ", true);
    return {};
  }
}


// Pobierz z localStorage lub []  
function getRecentProjects() {
  try { return JSON.parse(localStorage.getItem('recentProjects'))||[]; }
  catch { return []; }
}
function setRecentProjects(arr) {
  localStorage.setItem('recentProjects', JSON.stringify(arr));
}
// Przy wyborze projektu ‚Äì wrzuƒá na poczƒÖtek, usu≈Ñ duplikaty, zachowaj max 7
function updateRecentProjects(project) {
  // tylko 5 pierwszych
const recent = getRecentProjects().slice(0,5);

  const filtered = [project, ...recent.filter(p=>p!==project)];
  setRecentProjects(filtered.slice(0,7));
}


// renderowanie kafelk√≥w projekt√≥w
function renderProjects() {
  // tylko 5 pierwszych
const recent = getRecentProjects().slice(0,5);

  const recentContainer = document.getElementById('recent-projects');
  recentContainer.innerHTML = '';

  // *** DLA CEL√ìW DEBUGU dodaj na chwilƒô logi:
  console.log('renderProjects ‚Ü† recent:', recent, 'all projects:', projects);

  // zawsze pokazuj sekcjƒô (przynajmniej na czas test√≥w)
  document.getElementById('recent-projects-container').style.display = 'block';

  // render kafelk√≥w ‚Äûostatnio u≈ºywane‚Äù
  if (recent.length) {
    renderTiles('recent-projects', recent, selectProject);
    Array.from(recentContainer.children)
         .forEach(div => div.classList.add('recent'));
  }

  // render wszystkich projekt√≥w poni≈ºej
  document.getElementById('all-projects-container').style.display = 'block';
  renderTiles('projects', projects, selectProject);
  addCustomProjectTile();
}



// w resetForm: od razu z cache‚Äôu, bez fetcha
async function resetForm() {
  state = { worker: null, entries: [] };
  loadProjectsFromStorage();
  // ‚¨á‚¨á‚¨á To jest kluczowe
  if (gapiInited) {
    await fetchCategoriesFromSheet(); // ‚¨Ö‚¨Ö‚¨Ö poczekaj na pobranie zanim cokolwiek dalej!
  } else {
    setTimeout(resetForm, 250);
    return;
  }
  const statusMap = await fetchWorkerStatuses();
  showStep(1);
  renderTiles('workers', workers, worker => {
  state.worker = worker;
  // 1. Najpierw sprawdzamy overnight timer
  if (checkOvernightTimer(worker)) {
    return; // wy≈õwietli≈Ç popup, nie id≈∫ dalej!
  }
  // 2. Je≈õli nie overnight, sprawdzamy stare timery
  const oldTimers = loadTimerDataForWorker(worker);
  if (oldTimers.length > 0) {
    showPendingTimersScreen(oldTimers, worker);
    return;
  }
  showStep(2);
  renderProjects();
  updateTimerButtonVisibility();
}, statusMap);

}


function checkPendingSave() {
  const pending = localStorage.getItem("pendingSave");
  if (pending) {
    showToast("Masz niezapisane dane! Kliknij tutaj, aby spr√≥bowaƒá je zapisaƒá.", true);
    document.getElementById('toast').onclick = () => {
      actuallySubmitPendingData();
    };
  }
}

function formatSecondsHMS(sec) {
  sec = Math.floor(sec);
  const h = Math.floor(sec / 3600);
  const m = Math.floor((sec % 3600) / 60);
  const s = sec % 60;
  return [h, m, s].map(x=>x.toString().padStart(2,'0')).join(':');
}


async function actuallySubmitPendingData() {
  const pending = localStorage.getItem("pendingSave");
  if (!pending) return;
  try {
    const { values } = JSON.parse(pending);
    await gapi.client.sheets.spreadsheets.values.append({
      spreadsheetId: SPREADSHEET_ID,
      range: `${SHEET_NAME_SAVE}!A1`,
      valueInputOption: 'USER_ENTERED',
      insertDataOption: 'INSERT_ROWS',
      resource: { values }
    });
    localStorage.removeItem("pendingSave");
    showToast("Uda≈Ço siƒô zapisaƒá zaleg≈Çe dane!");
    resetForm();
  } catch (err) {
    showToast("Dalej nie uda≈Ço siƒô zapisaƒá! Twoje dane sƒÖ bezpieczne.", true);
  }
}



    // Zwraca string daty YYYY-MM-DD
function getDayString(offset = 0) {
    const d = new Date();
    d.setDate(d.getDate() + offset);
    return d.toISOString().split('T')[0];
}

// Zwraca listƒô {dayStr, data} z localStorage z 3 dni wstecz
function loadTimerDataForWorker(worker) {
    const result = [];
    for (let offset = 0; offset > -3; offset--) {
        const dayStr = getDayString(offset);
        const key = `timerData_${worker}_${dayStr}`;
        const data = JSON.parse(localStorage.getItem(key) || "null");
        if (data) result.push({ dayStr, data });
    }
    return result;
}

// Zapisz stan timera (np. "on" lub "off") dla aktualnego pracownika i dnia
function saveTimerState(worker, state) {
    const dayStr = getDayString();
    const key = `timerData_${worker}_${dayStr}`;
    let data = JSON.parse(localStorage.getItem(key) || "{}");
    data.timerState = state;
    localStorage.setItem(key, JSON.stringify(data));
}

// Odczytaj stan timera (on/off/inProgress)
function getTimerState(worker) {
    const dayStr = getDayString();
    const key = `timerData_${worker}_${dayStr}`;
    let data = JSON.parse(localStorage.getItem(key) || "{}");
    return data.timerState || "off";
}

async function deleteEntry(rowIndex) {
  if (!confirm("Czy na pewno chcesz usunƒÖƒá ten wpis? Tej operacji nie mo≈ºna cofnƒÖƒá.")) return;
  try {
    await withAuthRequest(() =>
      gapi.client.sheets.spreadsheets.values.clear({
        spreadsheetId: SPREADSHEET_ID,
        range: `${SHEET_NAME_SAVE}!A${rowIndex}:F${rowIndex}`
      })
    );
    showToast("Wpis zosta≈Ç usuniƒôty.");
    document.getElementById('entries-popup').remove();
    showRecentEntries();
  } catch (e) {
    console.error("B≈ÇƒÖd kasowania wpisu:", e);
    showToast("Nie uda≈Ço siƒô usunƒÖƒá wpisu.", true);
  }
}


async function editEntry(rowIndex) {
  // 1) Pobieramy starƒÖ warto≈õƒá
  const range = `${SHEET_NAME_SAVE}!A${rowIndex}:F${rowIndex}`;
  const getRes = await withAuthRequest(() =>
    gapi.client.sheets.spreadsheets.values.get({
      spreadsheetId: SPREADSHEET_ID,
      range
    })
  );
  const old = getRes.result.values?.[0] || [];
  const headers = ['Data','Pracownik','Projekt','Kategoria','Zadanie','Godziny'];

  // 2) Pytamy usera o nowe warto≈õci
  const updated = old.map((val,i) => {
    const inp = prompt(`Nowa warto≈õƒá dla ${headers[i]}:`, val);
    return inp == null ? val : inp;
  });

  // 3) Funkcja, kt√≥ra robi faktyczny update
  async function doUpdate() {
    await withAuthRequest(() =>
      gapi.client.sheets.spreadsheets.values.update({
        spreadsheetId: SPREADSHEET_ID,
        range,
        valueInputOption: 'USER_ENTERED',
        resource: { values: [updated] }
      })
    );
    showToast("Zaktualizowano wpis");
    document.getElementById('entries-popup').remove();
    showRecentEntries();
  }

  // 4) Token zawsze ju≈º bƒôdzie od≈õwie≈ºony, wiƒôc tylko wywo≈Çuj:
  await doUpdate();
}




function showToast(msg, isError = false) {
  const toast = document.getElementById('toast');
  if (!toast) {
    console.warn("Toast element nie istnieje:", msg);
    return;
  }

  toast.textContent = msg;
  toast.classList.toggle('error', isError);
  toast.style.display = 'block';
  setTimeout(() => {
    toast.style.display = 'none';
  }, 5000);
}


function updateClock() {
  const now = new Date();
  const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
  const dateStr = now.toLocaleDateString('pl-PL', options);
  const timeStr = now.toLocaleTimeString('pl-PL');
  document.getElementById('clock').innerText = `${dateStr}, ${timeStr}`;
}
setInterval(updateClock, 1000);
updateClock();


    // ‚Äî‚Äî‚Äî‚Äî‚Äî USTAWIENIA ‚Äî‚Äî‚Äî‚Äî‚Äî
    const API_KEY         = "AIzaSyDDihxqon-BeTzmC-vEE4kyhRJBXTlK_lA";
    const CLIENT_ID       = "614198520540-4ann4cs5o8pchgi1u15q6n08pj87n51o.apps.googleusercontent.com";
    const SPREADSHEET_ID  = "14t8T8GexDVVlO5v-C1T0VHz94LmM5FRRNg-sXPKh2GE";
    const DISCOVERY_DOCS  = ["https://sheets.googleapis.com/$discovery/rest?version=v4"];
    const SCOPES          = "https://www.googleapis.com/auth/spreadsheets";
    const SHEET_NAME_LOAD = "Projekty";
    const SHEET_NAME_SAVE = "CzasPracy";

    // ‚Äî‚Äî‚Äî‚Äî‚Äî ZMIENNE STANU OAuth ‚Äî‚Äî‚Äî‚Äî‚Äî
    let tokenClient;
    let gapiInited = false;
    let gisInited  = false;

    // ‚Äî‚Äî‚Äî‚Äî‚Äî CALLBACKI ≈ÅADOWANIA BIBLIOTEK ‚Äî‚Äî‚Äî‚Äî‚Äî
    function gapiLoaded() {
  gapi.load('client', () =>
    gapi.client.init({ apiKey: API_KEY, discoveryDocs: DISCOVERY_DOCS })
      .then(() => {
        gapiInited = true;
        resetForm(); // ‚Üê przenie≈õ tutaj
      })
  );
}


    function gisLoaded() {
  tokenClient = google.accounts.oauth2.initTokenClient({
    client_id: CLIENT_ID,
    scope: SCOPES,
    callback: (resp) => {
      if (resp.error) {
        console.error("Token error:", resp);
        return;
      }
      actuallySubmitData();
    }
  });
  gisInited = true;

  // >>> DODAJ TEN BLOK:
  // Automatyczne od≈õwie≈ºanie tokena co 50 minut (3000 sekund)
  setInterval(() => {
    if (gapiInited && gisInited) {
      try {
        tokenClient.requestAccessToken({ prompt: '' });
        console.log("Token Google od≈õwie≈ºony automatycznie.");
      } catch(e) {
        console.warn("Nie uda≈Ço siƒô od≈õwie≈ºyƒá tokena:", e);
      }
    }
  }, 50 * 60 * 1000); // 50 minut
  // <<< KONIEC BLOKU
}


    // ‚Äî‚Äî‚Äî‚Äî‚Äî DANE APLIKACJI ‚Äî‚Äî‚Äî‚Äî‚Äî
    const workers = ["Kamil","Pawe≈Ç","Piotr","Przemek","Robert"];

    async function fetchCategoriesFromSheet() {
  if (!gapiInited) return;
  try {
    const baseCategories = ["Stal", "Drewno", "Monta≈º", "Biuro"];
    const res = await withAuthRequest(() =>
      gapi.client.sheets.spreadsheets.values.get({
        spreadsheetId: SPREADSHEET_ID,
        range: `NoweKategorie!A2:A`
      })
    );
    const newCategories = res.result.values?.flat() || [];
    window.categories = Array.from(new Set([
      ...baseCategories,
      ...newCategories
    ].filter(Boolean)));
    renderTiles('categories', window.categories, selectCategory);
    showToast("Kategorie zaktualizowane z arkusza");
  } catch (e) {
    console.error("B≈ÇƒÖd pobierania kategorii:", e);
    showToast("B≈ÇƒÖd aktualizacji kategorii", true);
  }
}



    const subcategoriesMap = {
      "Stal": ["Konstrukcja","Balustrady"],
      "Drewno": ["Przygotowanie","Produkcja","Lakierowanie"],
      "Monta≈º": ["Transport","Konstrukcja","Stopnie/Podstopnie","Balustrady","Pozosta≈Çe"],
      "Biuro": ["Zakupy","Faktury","Telefon","Sketchup"]
    };
    let projects = [];
    let state = { worker: null, entries: [] };
    let currentEntry = null;
    let currentStep = 1;
    let timerMode = false; // false = normalny, true = timer
    let timerData = null;  // tutaj bƒôdziemy trzymaƒá obecny wpis timera
    let timerInterval = null; // do odliczania sekund


    // ‚Äî‚Äî‚Äî‚Äî‚Äî POMOCNICZE ‚Äî‚Äî‚Äî‚Äî‚Äî
    function showStep(step) {
  document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
  document.getElementById(`step${step}`).classList.add('active');
  const titles = [" ","Wybierz projekt","Wybierz kategoriƒô","Wybierz zadanie","Podsumowanie"];
  document.getElementById('step-title').innerText = titles[step-1];
  document.getElementById('addBtn').style.display = (step === 2 || step === 4) ? 'inline-block' : 'none';
  // ‚Äî poprawka:
  document.querySelectorAll('.back-button').forEach(btn => {
    document.getElementById('backBtn').style.display = (step === 1 || (step === 5 && timerMode)) ? 'none' : 'inline-block';
  });

  currentStep = step;
  if (step === 4) {
    document.getElementById('hourSection').style.display = 'none';
    renderHourTiles();
  }
  updateTimerButtonVisibility();
  updateSummaryButtonVisibility();

}

function selectCategory(category) {
  currentEntry.category = category;
  showStep(4);
  const staticList = subcategoriesMap[category] || [];
  const cached = getCachedTasks()[category] || [];
  renderTiles('subcategories', Array.from(new Set([...staticList, ...cached])), subcat => {
    currentEntry.subcategory = subcat;
    if (timerMode) {
      startTaskTimer(currentEntry);
    } else {
      document.getElementById('hourSection').style.display = 'block';
    }
  });
}



// ‚Äî‚Äî‚Äî‚Äî‚Äî Zaktualizowany handleAddCustom ‚Äî‚Äî‚Äî‚Äî‚Äî
function handleAddCustom() {
  if (currentStep === 2) { // Projekty
    const name = prompt("Podaj nazwƒô nowego projektu:");
    if (name && !projects.includes(name)) {
      projects.push(name);
      localStorage.setItem('projekty', JSON.stringify(projects));
      renderProjects();
      saveNewItemToSheet(name, 'NoweProjekty');
    }
  }

  if (currentStep === 3) { // Kategorie
    const name = prompt("Podaj nazwƒô nowej kategorii:");
    if (name && !categories.includes(name)) {
      categories.push(name);
      renderTiles('categories', window.categories, selectCategory);

      saveNewItemToSheet(name, 'NoweKategorie');
      showToast("Dodano nowƒÖ kategoriƒô");
    }
  }

  if (currentStep === 4 && currentEntry?.category) { // Zadania
    const name = prompt("Podaj nazwƒô nowego zadania:");
    const list = subcategoriesMap[currentEntry.category] || [];
    if (name && !list.includes(name)) {
      list.push(name);
      subcategoriesMap[currentEntry.category] = list;
      renderTiles('subcategories', list, subcat => {
  currentEntry.subcategory = subcat;
  if (timerMode) {
    startTaskTimer(currentEntry);
  } else {
    document.getElementById('hourSection').style.display = 'block';
  }
});

      saveNewTaskToSheet(currentEntry.category, name);
    }
  }
}


async function handleAddCategory() {
  const name = prompt("Podaj nazwƒô nowej kategorii:");
  if (!name) return;
  if (!categories.includes(name)) {
    categories.push(name);
    await saveNewItemToSheet(name, 'NoweKategorie');
    await fetchCategoriesFromSheet();  // ‚Üê dodaƒá to
    renderTiles('categories', window.categories, category => {
      currentEntry.category = category;
      showStep(4);
      const staticList = subcategoriesMap[category]||[];
      const cached = getCachedTasks()[category]||[];
      renderTiles('subcategories', Array.from(new Set([...staticList, ...cached])), subcat => {
        currentEntry.subcategory = subcat;
        document.getElementById('hourSection').style.display = 'block';
      });
    });
    showToast("Dodano nowƒÖ kategoriƒô");
  } else {
    showToast("Taka kategoria ju≈º istnieje!", true);
  }
}



async function saveNewItemToSheet(value, sheetName) {
  if (!value || !sheetName || !gapiInited) return;

  try {
    await withAuthRequest(() =>
      gapi.client.sheets.spreadsheets.values.append({
        spreadsheetId: SPREADSHEET_ID,
        range: `${sheetName}!A:A`,
        valueInputOption: 'USER_ENTERED',
        insertDataOption: 'INSERT_ROWS',
        resource: { values: [[value]] }
      })
    );
    showToast("Zapisano nowƒÖ pozycjƒô");
  } catch (err) {
    console.error("B≈ÇƒÖd zapisu nowej pozycji:", err);
    showToast("B≈ÇƒÖd zapisu nowej pozycji", true);
  }
}



    function goBack() {
      if (currentStep > 1) showStep(currentStep - 1);
    }

async function fetchWorkerStatuses() {
  const statusMap = {};
  const todayStr = new Date().toISOString().split("T")[0];

  // Spr√≥buj wczytaƒá z cache
  const cached = localStorage.getItem("workerStatusCache");
  if (cached) {
    try {
      const parsed = JSON.parse(cached);
      if (parsed.date === todayStr && parsed.statusMap) {
        return parsed.statusMap;
      }
    } catch (e) {
      console.warn("B≈ÇƒÖd parsowania cache:", e);
    }
  }

  try {
    const res = await withAuthRequest(() =>
      gapi.client.sheets.spreadsheets.values.get({
        spreadsheetId: SPREADSHEET_ID,
        range: `${SHEET_NAME_SAVE}!A2:F`,
      })
    );

    const entries = res.result.values || [];
    const yesterday = new Date();
    yesterday.setDate(yesterday.getDate() - 1);
    const yesterdayStr = yesterday.toISOString().split("T")[0];

    workers.forEach(worker => {
      const hasToday = entries.some(row =>
        row[0]?.startsWith(todayStr) && row[1] === worker
      );
      const hasYesterday = entries.some(row =>
        row[0]?.startsWith(yesterdayStr) && row[1] === worker
      );

      if (hasToday) statusMap[worker] = "green";
      else if (hasYesterday) statusMap[worker] = "yellow";
      else statusMap[worker] = "red";
    });

    localStorage.setItem("workerStatusCache", JSON.stringify({
      date: todayStr,
      statusMap
    }));

  } catch (e) {
    console.error("B≈ÇƒÖd pobierania status√≥w pracownik√≥w:", e);
    showToast("Nie uda≈Ço siƒô sprawdziƒá, kto siƒô wpisa≈Ç.", true);
  }

  return statusMap;
}





    function renderTiles(containerId, items, onClick, statusMap = {}) {
console.log("Rendertiles", { containerId, items, statusMap });

  const container = document.getElementById(containerId);
  container.innerHTML = '';
  const step = currentStep;

  const stepClass = {
    1: 'tile-step1',
    2: 'tile-step2',
    3: 'tile-step3',
    4: 'tile-step4'
  }[step] || 'tile';

  items.forEach(item => {
  const div = document.createElement('div');
  div.className = `tile ${stepClass}`;

  // Dodaj klasƒô statusu (je≈õli dotyczy)
  if (statusMap[item]) {
    div.classList.add(`tile-status-${statusMap[item]}`);
  }

  div.innerText = item;
  div.onclick = () => {
    div.classList.add('clicked');
    setTimeout(() => div.classList.remove('clicked'), 200);
    [...container.children].forEach(c => c.classList.remove('selected'));
    div.classList.add('selected');
    onClick(item);   // ‚Üê TYLKO TO
  };
  container.appendChild(div);
});

}


    // ‚Äî‚Äî‚Äî‚Äî‚Äî RESET I START ‚Äî‚Äî‚Äî‚Äî‚Äî
    function loadProjectsFromStorage() {
      const stored = localStorage.getItem('projekty');
      projects = stored ? JSON.parse(stored) : [];
    }

    async function resetForm() {
  state = { worker: null, entries: [], summaryDate: null };

  loadProjectsFromStorage();
  // *** NIE CZEKAJ na gapiInited tylko spr√≥buj zawsze pobraƒá kategorie z arkusza ***
  if (gapiInited) {
    await fetchCategoriesFromSheet();
  } else {
    // pr√≥buj a≈º siƒô za≈Çaduje!
    setTimeout(resetForm, 250);
    return;
  }

  const statusMap = await fetchWorkerStatuses();
  showStep(1);
  renderTiles('workers', workers, worker => {
  state.worker = worker;
console.log("Klikniƒôto pracownika:", worker);
console.log("Znaleziono stare timery:", loadTimerDataForWorker(worker));

  const oldTimers = loadTimerDataForWorker(worker);
  if (oldTimers.length > 0) {
    showPendingTimersScreen(oldTimers, worker);  // <-- ju≈º dzia≈Ça
    return;
  }
  showStep(2);
  renderProjects();
  updateTimerButtonVisibility();
}, statusMap);


}

    // ‚Äî‚Äî‚Äî‚Äî‚Äî DYNAMICZNE TILES ‚Äî‚Äî‚Äî‚Äî‚Äî
    function addCustomProject() {
  const name = prompt("Podaj nazwƒô nowego projektu:");
  if (name && !projects.includes(name)) {
    projects.push(name);
    localStorage.setItem('projekty', JSON.stringify(projects));
   renderProjects();

    // zapisujemy do arkusza NoweProjekty
    saveNewItemToSheet(name, 'NoweProjekty');
  }
}


    function addCustomProjectTile() {
      const t = document.createElement('div');
      t.className = 'tile';
      t.innerText = '+ Dodaj projekt';
      t.onclick = addCustomProject;
      document.getElementById('projects').appendChild(t);
    }

// ‚Äî‚Äî‚Äî‚Äî‚Äî NOWA funkcja do zapisu nowych zada≈Ñ w dw√≥ch kolumnach (kategoria + nazwa) ‚Äî‚Äî‚Äî‚Äî‚Äî
async function saveNewTaskToSheet(category, taskName) {
  if (!category || !taskName || !gapiInited) return;
  try {
    await withAuthRequest(() =>
      gapi.client.sheets.spreadsheets.values.append({
        spreadsheetId: SPREADSHEET_ID,
        range: `NoweZadania!A:B`, // kolumna A = kategoria, B = zadanie
        valueInputOption: 'USER_ENTERED',
        insertDataOption: 'INSERT_ROWS',
        resource: { values: [[category, taskName]] }
      })
    );
    showToast("Zapisano nowe zadanie");
  } catch (err) {
    console.error("B≈ÇƒÖd zapisu nowego zadania:", err);
    showToast("B≈ÇƒÖd zapisu nowego zadania", true);
  }
}



    // ‚Äî‚Äî‚Äî‚Äî‚Äî Modyfikacja selectProject ‚Üí wyb√≥r kategorii ‚Üí krok 4 ‚Äî‚Äî‚Äî‚Äî‚Äî
// po wyborze kategorii:
function selectProject(project) {
  updateRecentProjects(project);
  currentEntry = { project, category: null, subcategory: null, hours: 0 };

  // --- NOWE: obs≈Çuga trybu timera ---
  if (timerMode) {
    showStep(3);
    fetchCategoriesFromSheet().then(() => {
      renderTiles('categories', window.categories, cat => {
        currentEntry.category = cat;
        showStep(4);
        const staticList = subcategoriesMap[cat] || [];
        const cached = getCachedTasks()[cat] || [];
        renderTiles(
          'subcategories',
          Array.from(new Set([...staticList, ...cached])),
          subcat => {
            currentEntry.subcategory = subcat;
            // --- START TIMERA ---
            startTaskTimer(currentEntry);
          }
        );
      });
    });
    return; // NIE kontynuuj starej ≈õcie≈ºki!
  }

  // --- Stary tryb normalny ---
  showStep(3);
  fetchCategoriesFromSheet().then(() => {
    renderTiles('categories', window.categories, cat => {
      currentEntry.category = cat;
      showStep(4);
      const staticList = subcategoriesMap[cat] || [];
      const cached = getCachedTasks()[cat] || [];
      renderTiles(
        'subcategories',
        Array.from(new Set([...staticList, ...cached])),
        subcat => {
          currentEntry.subcategory = subcat;
          if (timerMode) {
            startTaskTimer(currentEntry);
          } else {
            document.getElementById('hourSection').style.display = 'block';
          }
        }
      );
    });
  });
}



function stopCurrentTaskTimer() {
    if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
    }
    if (timerData && timerData.isRunning) {
        // Dodaj czas do totalSeconds
        const now = Date.now();
        timerData.totalSeconds += Math.floor((now - timerData.startTime) / 1000);
        timerData.isRunning = false;
    }
}
function toggleStartStopTimer() {
    const dateStr = getDayString();
    let data = getFullTimerData(state.worker, dateStr);

    // Znajd≈∫ ostatniƒÖ sesjƒô (powinna byƒá tylko jedna z isRunning==true lub ≈ºadna)
    let session = data.sessions && data.sessions.length ? data.sessions[data.sessions.length - 1] : null;
    if (!session) return;

    if (session.isRunning) {
        // STOP ‚Äì wstrzymujemy licznik
        session.endTime = Date.now();
        session.isRunning = false;
        session.duration += Math.floor((session.endTime - session.startTime) / 1000);
        clearInterval(timerInterval);
        setFullTimerData(state.worker, dateStr, data);
    } else {
        // START ‚Äì wznawiamy licznik
        session.startTime = Date.now();
        session.isRunning = true;
        setFullTimerData(state.worker, dateStr, data);
        timerInterval = setInterval(renderTimerSummary, 1000);
    }
    renderFullSummary();
    updateTimerButtonVisibility();
}


function renderFullSummary(workerOverride = null, dateStrOverride = null) {
  state.summaryDate = dateStrOverride || getDayString();

  const summary = document.getElementById('summary');
  summary.innerHTML = '';
  const worker = workerOverride || state.worker;
  const dateStr = dateStrOverride || getDayString();

  // Wpisy formularzowe (tylko z dzisiaj i tylko dla aktywnego u≈ºytkownika)
  const manualEntries = (state.worker === worker && dateStr === getDayString()) ? state.entries : [];

  // Timery z localStorage
  let timerData = getFullTimerData(worker, dateStr);
  let sessions = timerData.sessions || [];

  // Suma wszystkich sekund
  let totalSeconds = 0;

  // 1. Najpierw wpisy formularzowe (kafelki z godzinami)
  if (manualEntries.length > 0) {
    const container = document.createElement('div');
    container.className = 'summary-entry-container';
    manualEntries.forEach((e, i) => {
      totalSeconds += (typeof e.hours === "number" ? e.hours * 3600 : 0);
      const div = document.createElement('div');
      div.className = 'summary-entry';
      div.innerHTML = `
        <button class="remove-btn" onclick="removeEntry(${i})">‚ùå</button>
        <p><strong>${e.project}</strong><br>${e.category} / ${e.subcategory}</p>
        <div class="hour-options">
          ${Array.from({length:16},(_,h)=> {
            const hv = h+1;
            return `<div class="tile ${e.hours===hv?'selected':''}" onclick="updateHours(${i},${hv})">${hv}</div>`;
          }).join('')}
        </div>
      `;
      container.appendChild(div);
    });
    summary.appendChild(container);
  }

  // 2. Potem wpisy z timera (ka≈ºda sesja)
  let anySessionRunning = false;
  if (sessions.length > 0) {
    sessions.forEach((session, idx) => {
      let elapsed = session.duration || 0;
      if (session.isRunning) {
        elapsed += Math.floor((Date.now() - session.startTime) / 1000);
        anySessionRunning = true;
      }
      totalSeconds += elapsed;
      const h = Math.floor(elapsed / 3600);
      const m = Math.floor((elapsed % 3600) / 60);
      const s = elapsed % 60;
      const elapsedStr = [h, m, s].map(x => x.toString().padStart(2, '0')).join(':');

      let btns = '';
      if (session.isRunning) {
        btns += `<button onclick="pauseTimerSession(${idx},'${worker}','${dateStr}')">‚èπÔ∏è Stop</button>`;
      } else {
        btns += `<button onclick="resumeTimerSession(${idx},'${worker}','${dateStr}')">‚ñ∂Ô∏è Wzn√≥w</button>`;
      }
      btns += `<button onclick="deleteTimerSession(${idx},'${worker}','${dateStr}')" style="margin-left:8px;">‚ùå Usu≈Ñ</button>`;

      summary.innerHTML += `
        <div class="summary-entry row-timer">
          <span class="timer-col project"><b>${session.project}</b></span>
          <span class="timer-col category">${session.category}</span>
          <span class="timer-col subcategory">${session.subcategory}</span>
          <span class="timer-col time" id="timer-value-${idx}">${elapsedStr}</span>
          <span class="timer-col button">${btns}</span>
        </div>
      `;
    });

    // ≈ªywy licznik ‚Äì je≈õli co≈õ jest aktywne
    if (sessions.some(s => s.isRunning)) {
      if (!window.__fullSummaryTimer) {
        window.__fullSummaryTimer = setInterval(() => renderFullSummary(worker, dateStr), 1000);
      }
    } else {
      if (window.__fullSummaryTimer) {
        clearInterval(window.__fullSummaryTimer);
        window.__fullSummaryTimer = null;
      }
    }
  }

  // 3. Suma wszystkich godzin na dole
  const totalSpan = document.getElementById('totalHours');
  if (totalSpan) {
    totalSpan.innerText = formatSecondsHMS(totalSeconds);
    totalSpan.className = `total-hours ${totalSeconds>9*3600?'red':'green'}`;
  }

  // --- KLUCZ: logika widoczno≈õci przycisku ‚ÄûDodaj kolejny projekt‚Äù ---
  const btn = document.querySelector('button[onclick="addAnotherProject()"]');
  if (btn) {
    // Ukryj je≈õli: timerMode i JAKIKOLWIEK session.isRunning === true
    btn.style.display = (timerMode && anySessionRunning) ? 'none' : '';
  }
}




function pauseTimerSession(idx, workerOverride = null, dateStrOverride = null) {
    const worker = workerOverride || state.worker;
    const dateStr = dateStrOverride || getDayString();
    let data = getFullTimerData(worker, dateStr);
    let session = data.sessions[idx];
    if (!session || !session.isRunning) return;

    // Zako≈Ñcz czas dla tej sesji
    session.endTime = Date.now();
    session.isRunning = false;
    session.duration += Math.floor((session.endTime - session.startTime) / 1000);

    setFullTimerData(worker, dateStr, data);

    if (window.__fullSummaryTimer) {
      clearInterval(window.__fullSummaryTimer);
      window.__fullSummaryTimer = null;
    }

    renderFullSummary(worker, dateStr);
    updateTimerButtonVisibility();
}

function resumeTimerSession(idx, workerOverride = null, dateStrOverride = null) {
    const worker = workerOverride || state.worker;
    const dateStr = dateStrOverride || getDayString();
    let data = getFullTimerData(worker, dateStr);

    // Najpierw zatrzymaj ka≈ºdƒÖ innƒÖ aktywnƒÖ sesjƒô (≈ºeby zawsze by≈Ça tylko jedna aktywna)
    data.sessions.forEach((s, i) => {
        if (s.isRunning) {
            s.endTime = Date.now();
            s.isRunning = false;
            s.duration += Math.floor((s.endTime - s.startTime) / 1000);
        }
    });

    // Wzn√≥w wskazanƒÖ sesjƒô
    let session = data.sessions[idx];
    if (!session || session.isRunning) return;
    session.startTime = Date.now();
    session.isRunning = true;

    setFullTimerData(worker, dateStr, data);

    if (window.__fullSummaryTimer) clearInterval(window.__fullSummaryTimer);
    window.__fullSummaryTimer = setInterval(() => renderFullSummary(worker, dateStr), 1000);

    renderFullSummary(worker, dateStr);
    updateTimerButtonVisibility();
}

function deleteTimerSession(idx, workerOverride = null, dateStrOverride = null) {
    const worker = workerOverride || state.worker;
    const dateStr = dateStrOverride || getDayString();
    let data = getFullTimerData(worker, dateStr);
    if (!data.sessions) return;
    data.sessions.splice(idx, 1);

    // Je≈õli nie ma ≈ºadnych sesji, wy≈ÇƒÖcz timerState
    if (data.sessions.length === 0) {
        data.timerState = "off";
        if (window.__fullSummaryTimer) {
            clearInterval(window.__fullSummaryTimer);
            window.__fullSummaryTimer = null;
        }
    }
    setFullTimerData(worker, dateStr, data);
    renderFullSummary(worker, dateStr);
    updateTimerButtonVisibility();
    showToast("Usuniƒôto timer");
}






function startTaskTimer(entry) {
    stopCurrentTaskTimer(); // zamknij, je≈õli co≈õ ju≈º by≈Ço

    // Pobierz dane z localStorage na dzi≈õ
    const dateStr = getDayString();
    let data = getFullTimerData(state.worker, dateStr);

    // Je≈õli jest aktywna sesja ‚Äî domkniƒôcie czasu
    if (data.sessions && data.sessions.length && data.sessions[data.sessions.length-1].isRunning) {
        // zatrzymaj poprzedniƒÖ
        const prev = data.sessions[data.sessions.length-1];
        prev.endTime = Date.now();
        prev.isRunning = false;
        prev.duration = Math.floor((prev.endTime - prev.startTime)/1000);
    }

    // Dodaj nowƒÖ sesjƒô
    const newSession = {
        ...entry,
        startTime: Date.now(),
        endTime: null,
        isRunning: true,
        duration: 0 // w sekundach
    };
    data.sessions = data.sessions || [];
    data.sessions.push(newSession);

    data.timerState = "inProgress";
    setFullTimerData(state.worker, dateStr, data);

    timerData = newSession; // trzymamy aktualny wpis

    // Ekran podsumowania
    showStep(5);

    // **NOWO≈öƒÜ ‚Äî automatyczny podglƒÖd timera w podsumowaniu**
    if (window.__fullSummaryTimer) clearInterval(window.__fullSummaryTimer);
    window.__fullSummaryTimer = setInterval(() => renderFullSummary(), 1000);

    renderFullSummary(); // <- renderuj od razu, nie czekaj na klikniƒôcie!

    // Ukryj "Dodaj kolejny projekt" tylko gdy jest tryb timera
    const btn = document.querySelector('button[onclick="addAnotherProject()"]');
    if (btn) btn.style.display = timerMode ? 'none' : '';

    updateTimerButtonVisibility();
}




// obs≈Çuga przycisku
async function handleUpdateTasks() {
  if (!currentEntry?.category) return;
  const tasksByCat = await fetchTasksFromSheet();
  const list = Array.from(new Set([
    ...(subcategoriesMap[currentEntry.category]||[]),
    ...(tasksByCat[currentEntry.category]||[])
  ]));
  renderTiles('subcategories', list, subcat => {
    currentEntry.subcategory = subcat;
    document.getElementById('hourSection').style.display = 'block';
  });
  showToast("Zadania zaktualizowane");
}



    function renderHourTiles() {
      const c = document.getElementById('hourTiles');
      c.innerHTML = '';
      for (let i=1; i<=16; i++){
        const d = document.createElement('div');
        d.className = 'tile';
        d.innerText = i;
        d.onclick = () => {
          currentEntry.hours = i;
          tryFinishEntry();
        };
        c.appendChild(d);
      }
    }

    function tryFinishEntry() {
      if (currentEntry.subcategory && currentEntry.hours>0) {
        state.entries.push({ ...currentEntry });
        showStep(5);
        renderFullSummary();
      }
    }

    


    function removeEntry(idx) {
      state.entries.splice(idx,1);
      renderFullSummary();
    }
    function updateHours(idx,val) {
      state.entries[idx].hours = val;
      renderFullSummary();
    }

function addAnotherProject(){
    if (timerMode) {
        const dateStr = getDayString();
        let data = getFullTimerData(state.worker, dateStr);
        // Je≈õli JAKIKOLWIEK timer jest isRunning ‚Äì blokujemy dodanie nowego zadania
        if (data.sessions && data.sessions.some(s => s.isRunning)) {
            showToast("Najpierw zatrzymaj aktualny pomiar (STOP)", true);
            return;
        }
    }
    // Czy≈õƒá licznik interwa≈Çu po wyj≈õciu z podsumowania
    if (window.__fullSummaryTimer) {
        clearInterval(window.__fullSummaryTimer);
        window.__fullSummaryTimer = null;
    }
    showStep(2);
    renderProjects();
}

function checkOvernightTimers(worker, dateStr) {
  // Pobierz dane timer√≥w u≈ºytkownika
  const timerData = getFullTimerData(worker, dateStr);
  const sessions = timerData.sessions || [];

  const today = new Date().toDateString();

  // Przejd≈∫ po wszystkich aktywnych sesjach
  sessions.forEach((session, idx) => {
    if (session.isRunning) {
      const start = new Date(session.startTime);
      // Je≈õli startTime to NIE dzisiejsza data:
      if (start.toDateString() !== today) {
        // Poka≈º popup TYLKO raz na wej≈õcie!
        if (!window.__overnightPopupShown) {
          window.__overnightPopupShown = true;
          setTimeout(() => {
            if (confirm(
              "WyglƒÖda na to, ≈ºe timer zosta≈Ç uruchomiony wczoraj (" +
              start.toLocaleString() +
              ").\nCzy chcesz zaliczyƒá ca≈Çy czas do dzisiaj (co mo≈ºe daƒá zbyt wiele godzin), czy zako≈Ñczyƒá timer wczoraj (i wpisaƒá faktyczny czas zako≈Ñczenia)?\n\nKliknij OK, aby zako≈Ñczyƒá timer na koniec wczorajszego dnia, lub Anuluj, aby zostawiƒá jak jest."
            )) {
              // Ustaw duration do ko≈Ñca dnia startu (np. 23:59:59)
              const endOfStartDay = new Date(start);
              endOfStartDay.setHours(23, 59, 59, 999);
              session.duration += Math.floor((endOfStartDay - start) / 1000);
              session.isRunning = false;
              session.startTime = null;
              saveFullTimerData(worker, dateStr, timerData);
              alert("Timer zosta≈Ç zako≈Ñczony na koniec dnia " + start.toLocaleDateString());
              renderFullSummary(worker, dateStr);
            }
            // Je≈õli Anuluj, timer zostaje jak jest ‚Äî mo≈ºe naliczyƒá 20h
          }, 100); // ma≈Çy delay, by nie zblokowaƒá interfejsu
        }
      }
    }
  });
}


    // ‚Äî‚Äî‚Äî‚Äî‚Äî ZAPIS DO SHEETS ‚Äî‚Äî‚Äî‚Äî‚Äî
    function submitData() {
      if (!gapiInited || !gisInited) {
        alert("Trwa inicjalizacja Google API, spr√≥buj za chwilƒô.");
        return;
      }
      const tok = gapi.client.getToken();
      if (!tok) {
        tokenClient.requestAccessToken({ prompt: '' });
      } else {
        actuallySubmitData();
      }
    }

   async function actuallySubmitData() {
  try {
    let values = [];
    // ‚Äî normalne wpisy (nie-timerowe)
    if (state.entries && state.entries.length) {
      values = state.entries.map(e => [
        formatDateForSheets(new Date()),
        state.worker,
        e.project,
        e.category,
        e.subcategory,
        (typeof e.hours === "number") ? e.hours * 3600 : 0 // zamie≈Ñ na sekundy
      ]);
    }

    // ‚Äî wpisy z timera:
    const dateStr = state.summaryDate || getDayString();
    let data = getFullTimerData(state.worker, dateStr);
    if (data.sessions && data.sessions.length) {
      data.sessions.forEach(s => {
        values.push([
          formatDateForSheets(new Date(s.startTime)),
          state.worker,
          s.project,
          s.category,
          s.subcategory,
          Math.floor(s.duration || 0) // SECONDS
        ]);
      });
      // UWAGA: NIE kasuj localStorage na tym etapie!
      // Kasujemy dopiero po sukcesie (poni≈ºej)
    }

    if (!values.length) {
      showToast("Brak danych do zapisania!", true);
      return;
    }

    // ‚Äî‚Äî‚Äî [NOWO≈öƒÜ] ‚Äî‚Äî‚Äî
    // Przed pr√≥bƒÖ zapisu do Google Sheets ‚Äî ZAPISZ dane do localStorage!
    localStorage.setItem("pendingSave", JSON.stringify({
      values,
      worker: state.worker,
      date: new Date().toISOString()
    }));

    // Pr√≥ba zapisu do Google Sheets
    await gapi.client.sheets.spreadsheets.values.append({
      spreadsheetId: SPREADSHEET_ID,
      range: `${SHEET_NAME_SAVE}!A1`,
      valueInputOption: 'USER_ENTERED',
      insertDataOption: 'INSERT_ROWS',
      resource: { values }
    });

    // ‚Äî‚Äî‚Äî PO SUKCESIE ‚Äî‚Äî‚Äî
    // Kasujemy zaleg≈Çe dane, bo ju≈º sƒÖ w arkuszu
    localStorage.removeItem("pendingSave");

    // Czy≈õcimy dane timer√≥w tylko je≈õli siƒô powiod≈Ço!
    localStorage.removeItem(getTimerStorageKey(state.worker, dateStr));
    // Usu≈Ñ cache status√≥w, ≈ºeby przy resetForm() pobraƒá je na nowo
    localStorage.removeItem("workerStatusCache");

    resetForm();
    showToast("Dane zosta≈Çy zapisane!");
  } catch (err) {
    console.error("B≈ÇƒÖd zapisu:", err);
    // NIE kasujemy pendingSave! Dane zostajƒÖ na nastƒôpnƒÖ pr√≥bƒô.
    showToast("B≈ÇƒÖd zapisu! Twoje dane sƒÖ zachowane. Spr√≥buj ponownie.", true);
  }
}




    // ‚Äî‚Äî‚Äî‚Äî‚Äî ZAMIENNIK fetchProjectsFromSheet ‚Äî‚Äî‚Äî‚Äî‚Äî
async function fetchProjectsFromSheet() {
  if (!gapiInited) return;
  try {
    const [base, custom] = await Promise.all([
      withAuthRequest(() =>
        gapi.client.sheets.spreadsheets.values.get({
          spreadsheetId: SPREADSHEET_ID,
          range: `${SHEET_NAME_LOAD}!A2:A`
        })
      ),
      withAuthRequest(() =>
        gapi.client.sheets.spreadsheets.values.get({
          spreadsheetId: SPREADSHEET_ID,
          range: `NoweProjekty!A2:A`
        })
      )
    ]);
    const baseList   = base.result.values?.flat()   || [];
    const customList = custom.result.values?.flat() || [];
    window.projects = Array.from(new Set([...baseList, ...customList].filter(Boolean)));
    setCachedProjects(window.projects);
    renderProjects(); 
    showToast("Projekty zaktualizowane");
  } catch (e) {
    console.error("B≈ÇƒÖd pobierania projekt√≥w:", e);
    showToast("B≈ÇƒÖd pobierania projekt√≥w", true);
  }
}


// ‚Äî‚Äî‚Äî‚Äî‚Äî NOWA funkcja pobierajƒÖca zadania z arkusza NoweZadania ‚Äî‚Äî‚Äî‚Äî‚Äî
async function fetchSubcategoriesFromSheet(category) {
  if (!gapiInited) return [];
  try {
    const res = await gapi.client.sheets.spreadsheets.values.get({
      spreadsheetId: SPREADSHEET_ID,
      range: `NoweZadania!A2:B`
    });
    const rows = res.result.values || [];
    return rows
      .filter(row => row[0] === category && row[1])
      .map(row => row[1]);
  } catch (e) {
    console.error("B≈ÇƒÖd pobierania nowych zada≈Ñ:", e);
    return [];
  }
}


function formatDateForSheets(date) {
  const pad = n => n.toString().padStart(2, '0');
  return `${date.getFullYear()}-${pad(date.getMonth()+1)}-${pad(date.getDate())} ${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}`;
}

const TIMER_USERS = ["Kamil", "Pawe≈Ç"];

function getDayString(offset = 0) {
    const d = new Date();
    d.setDate(d.getDate() + offset);
    return d.toISOString().split('T')[0];
}




// Obiekt z sesjami ‚Äî zapisujemy pod kluczem timerData_<worker>_<data>
function getFullTimerData(worker, dateStr) {
    const key = getTimerStorageKey(worker, dateStr);
    return JSON.parse(localStorage.getItem(key) || '{"sessions":[],"timerState":"off"}');
}

function setFullTimerData(worker, dateStr, data) {
    const key = getTimerStorageKey(worker, dateStr);
    localStorage.setItem(key, JSON.stringify(data));
}

function checkOvernightTimer(worker) {
  const now = new Date();
  const todayStr = getDayString();
  const timers = loadTimerDataForWorker(worker);

  for (const { dayStr, data } of timers) {
    if (!data.sessions || !data.sessions.length) continue;
    for (const session of data.sessions) {
      if (session.isRunning && session.startTime) {
        const sessionDate = new Date(session.startTime);
        const sessionDayStr = sessionDate.toISOString().split('T')[0];
        if (sessionDayStr !== todayStr) {
          // Timer zaczƒÖ≈Ç siƒô innego dnia!
          showOvernightTimerPopup({ worker, dayStr, session });
          return true; // znalaz≈Ço i pokaza≈Ço popup, ko≈Ñczymy
        }
      }
    }
  }
  return false; // nie znaleziono
}

function showOvernightTimerPopup({worker, dayStr, session}) {
  const startDate = new Date(session.startTime);
  const now = new Date();
  const elapsed = Math.floor((now - startDate) / 1000);
  const h = Math.floor(elapsed / 3600);
  const m = Math.floor((elapsed % 3600) / 60);
  const s = elapsed % 60;
  const elapsedStr = [h, m, s].map(x => x.toString().padStart(2, '0')).join(':');

  // Prosty modal
  const html = `
    <div id="overnight-popup" style="position:fixed;top:16%;left:50%;transform:translateX(-50%);
      background:white;padding:24px 18px;box-shadow:0 0 20px #0003;z-index:9999;border-radius:16px;max-width:330px">
      <h3>Wykryto timer z poprzedniego dnia!</h3>
      <p>
        Timer rozpoczƒôty: <b>${startDate.toLocaleString()}</b><br>
        Aktualny czas: <b>${now.toLocaleString()}</b><br>
        <b>≈ÅƒÖczny czas:</b> ${elapsedStr}
      </p>
      <button onclick="acceptOvernightTimer('${worker}','${dayStr}')">
        Zako≈Ñcz timer i zapisz ca≈Çy czas (${elapsedStr})
      </button>
      <button style="margin-left:12px" onclick="editOvernightTimer('${worker}','${dayStr}','${session.startTime}')">
        Podaj rƒôcznie godzinƒô zako≈Ñczenia
      </button>
      <br><br>
      <button class="back-button" onclick="closeOvernightPopup()">Anuluj</button>
    </div>
  `;
  document.getElementById('overnight-popup')?.remove();
  const div = document.createElement('div');
  div.innerHTML = html;
  document.body.appendChild(div);
}

function closeOvernightPopup() {
  document.getElementById('overnight-popup')?.remove();
}

function acceptOvernightTimer(worker, dayStr) {
  let data = getFullTimerData(worker, dayStr);
  let session = (data.sessions||[]).find(s => s.isRunning);
  if (!session) return;
  session.endTime = Date.now();
  session.duration += Math.floor((session.endTime - session.startTime)/1000);
  session.isRunning = false;
  setFullTimerData(worker, dayStr, data);
  closeOvernightPopup();
  showToast("Timer zako≈Ñczony ‚Äì mo≈ºesz go teraz zapisaƒá");
  showStep(5);
  renderOldTimerSummary(worker, dayStr);
}

function editOvernightTimer(worker, dayStr, startTime) {
  const val = prompt("Podaj godzinƒô zako≈Ñczenia (HH:MM, np. 18:30):", "18:00");
  if (!val) return;
  const [hh, mm] = val.split(':').map(Number);
  if (isNaN(hh) || isNaN(mm)) {
    showToast("Nieprawid≈Çowy format godziny!", true);
    return;
  }
  let endDate = new Date(Number(startTime));
  endDate.setHours(hh, mm, 0, 0);
  let endTime = endDate.getTime();
  if (endTime < startTime) endTime += 24*3600*1000; // na wypadek przekroczenia p√≥≈Çnocy

  let data = getFullTimerData(worker, dayStr);
  let session = (data.sessions||[]).find(s => s.isRunning);
  if (!session) return;
  session.endTime = endTime;
  session.duration += Math.floor((endTime - session.startTime)/1000);
  session.isRunning = false;
  setFullTimerData(worker, dayStr, data);
  closeOvernightPopup();
  showToast("Czas poprawiony ‚Äì mo≈ºesz go teraz zapisaƒá");
  showStep(5);
  renderOldTimerSummary(worker, dayStr);
}


function updateTimerButtonVisibility() {
    const btn = document.getElementById('timer-toggle-btn');
    if (!state.worker || !TIMER_USERS.includes(state.worker)) {
        btn.style.display = 'none';
        return;
    }
    btn.style.display = 'inline-block';

    const dateStr = getDayString();
    const data = getFullTimerData(state.worker, dateStr);
    // ≈ª√≥≈Çty ‚Äî gdy jest choƒá jedna sesja niezapisana lub trwa
    const anyActive = (data.sessions||[]).some(s => s.isRunning || !s.savedToSheet);
    let timerState = data.timerState || "off";

    if (anyActive) timerState = "inProgress"; // lub "yellow"
    btn.textContent = (timerState === 'on' ? "‚è± Timer: ON" :
                      timerState === 'off' ? "‚è± Timer: OFF" :
                      "‚è± Timer: W TRAKCIE");
    btn.style.background = timerState === 'on' ? "#28a745" : 
                          timerState === 'off' ? "#d80000" : "#ffc107";
    btn.style.color = (timerState === 'on' || timerState === 'off') ? "#fff" : "#222";
}


function handleTimerToggle() {
    if (!state.worker || !TIMER_USERS.includes(state.worker)) return;

    const dateStr = state.summaryDate || getDayString();
    const data = getFullTimerData(state.worker, dateStr);

    // Czy jest aktywna jakakolwiek sesja?
    const anyActive = (data.sessions||[]).some(s => s.isRunning);

    let timerState = getTimerState(state.worker);

    if (timerState === "off") {
        // W≈ÇƒÖcz tryb timera
        timerState = "on";
        timerMode = true;
        showToast("Tryb timera W≈ÅƒÑCZONY");
    } else if (timerState === "on" || timerState === "inProgress") {
        // Je≈õli jest aktywny timer ‚Äì NIE pozwalaj wy≈ÇƒÖczyƒá trybu!
        if (anyActive) {
            showToast("Najpierw zatrzymaj wszystkie aktywne timery!", true);
            return;
        }
        // Wy≈ÇƒÖcz tryb timera (i pozw√≥l na manual)
        timerState = "off";
        timerMode = false;
        showToast("Tryb timera WY≈ÅƒÑCZONY ‚Äì mo≈ºesz dodawaƒá rƒôczne wpisy");
    }

    saveTimerState(state.worker, timerState);
    updateTimerButtonVisibility();
    renderFullSummary();
}


function goToSummary() {
  showStep(5);
  if (timerMode) renderFullSummary();
  else renderFullSummary();
}



    // ‚Äî‚Äî‚Äî‚Äî‚Äî START ‚Äî‚Äî‚Äî‚Äî
  </script>
<!-- Eruda: <script src="https://cdn.jsdelivr.net/npm/eruda"></script> < --konsola na urzƒÖdzeniach mobilnych -->
<script>
  document.addEventListener('DOMContentLoaded', () => {
    eruda.init({
      // kt√≥re narzƒôdzia pokazaƒá
      tool: ['console', 'elements', 'network', 'resources'],
      // domy≈õlne opcje
      defaults: {
        // automatycznie poka≈º panel po init()
        autoShow: true,
        // procent wysoko≈õci ekranu dla panelu
        displaySize: 40
      }
    });
    // wymuszone otwarcie
    eruda.show();
  });
gapiLoaded();
gisLoaded();
</script>


</body>
</html>
